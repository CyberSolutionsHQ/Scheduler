{
  "meta": {
    "schema_version": "1.0.0",
    "phase": 3,
    "generated_at": "2025-12-21T05:45:33.327259+00:00",
    "agent": "context-architect-compiler",
    "inputs": {
      "manifest_path": "./context_logs/manifest.json",
      "live_schema_path": "./context_logs/live_schema.json"
    }
  },
  "resolution": {
    "status": "blocked",
    "conflicts": [
      {
        "kind": "type_mismatch",
        "manifest_ref": "companies.id",
        "live_ref": "public.companies.id",
        "message": "Column type differs for 'companies.id'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "users.id",
        "live_ref": "public.users.id",
        "message": "Column type differs for 'users.id'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "users.role",
        "live_ref": "public.users.role",
        "message": "Column type differs for 'users.role'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "employees.id",
        "live_ref": "public.employees.id",
        "message": "Column type differs for 'employees.id'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "job_sites.id",
        "live_ref": "public.job_sites.id",
        "message": "Column type differs for 'job_sites.id'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "schedules.id",
        "live_ref": "public.schedules.id",
        "message": "Column type differs for 'schedules.id'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "shifts.id",
        "live_ref": "public.shifts.id",
        "message": "Column type differs for 'shifts.id'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "shifts.schedule_id",
        "live_ref": "public.shifts.schedule_id",
        "message": "Column type differs for 'shifts.schedule_id'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "credential_reset_requests.id",
        "live_ref": "public.credential_reset_requests.id",
        "message": "Column type differs for 'credential_reset_requests.id'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "credential_reset_requests.request_type",
        "live_ref": "public.credential_reset_requests.request_type",
        "message": "Column type differs for 'credential_reset_requests.request_type'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "credential_reset_requests.status",
        "live_ref": "public.credential_reset_requests.status",
        "message": "Column type differs for 'credential_reset_requests.status'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "credential_reset_requests.requested_by_user_id",
        "live_ref": "public.credential_reset_requests.requested_by_user_id",
        "message": "Column type differs for 'credential_reset_requests.requested_by_user_id'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "credential_reset_requests.target_user_id",
        "live_ref": "public.credential_reset_requests.target_user_id",
        "message": "Column type differs for 'credential_reset_requests.target_user_id'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "requests.id",
        "live_ref": "public.requests.id",
        "message": "Column type differs for 'requests.id'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "requests.type",
        "live_ref": "public.requests.type",
        "message": "Column type differs for 'requests.type'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "requests.status",
        "live_ref": "public.requests.status",
        "message": "Column type differs for 'requests.status'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "job_types.id",
        "live_ref": "public.job_types.id",
        "message": "Column type differs for 'job_types.id'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "crews.id",
        "live_ref": "public.crews.id",
        "message": "Column type differs for 'crews.id'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "crew_members.id",
        "live_ref": "public.crew_members.id",
        "message": "Column type differs for 'crew_members.id'."
      },
      {
        "kind": "type_mismatch",
        "manifest_ref": "shift_jobs.id",
        "live_ref": "public.shift_jobs.id",
        "message": "Column type differs for 'shift_jobs.id'."
      }
    ],
    "decisions": [
      {
        "action": "cast",
        "from": "text",
        "to": "uuid",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "uuid",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "USER-DEFINED",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "uuid",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "uuid",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "uuid",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "uuid",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "uuid",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "uuid",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "USER-DEFINED",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "USER-DEFINED",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "uuid",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "uuid",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "uuid",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "USER-DEFINED",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "USER-DEFINED",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "uuid",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "uuid",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "uuid",
        "reason": "Manifest type does not match live column type."
      },
      {
        "action": "cast",
        "from": "text",
        "to": "uuid",
        "reason": "Manifest type does not match live column type."
      }
    ]
  },
  "entities": {
    "tables": [
      {
        "schema": "auth",
        "name": "audit_log_entries",
        "columns": [
          {
            "name": "instance_id",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "payload",
            "data_type": "json",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "ip_address",
            "data_type": "character varying",
            "nullable": false,
            "default": "''::character varying",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "audit_log_entries_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "audit_logs_instance_id_idx",
            "columns": [
              "instance_id"
            ],
            "unique": false,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "flow_state",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "user_id",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "auth_code",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "code_challenge_method",
            "data_type": "USER-DEFINED",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "code_challenge",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "provider_type",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "provider_access_token",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "provider_refresh_token",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "authentication_method",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "auth_code_issued_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "flow_state_created_at_idx",
            "columns": [
              "created_at"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "flow_state_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "idx_auth_code",
            "columns": [
              "auth_code"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "idx_user_id_auth_method",
            "columns": [
              "user_id",
              "authentication_method"
            ],
            "unique": false,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "identities",
        "columns": [
          {
            "name": "provider_id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "user_id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "users",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "identity_data",
            "data_type": "jsonb",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "provider",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "last_sign_in_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "email",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "provider_id",
            "provider"
          ]
        ],
        "indexes": [
          {
            "name": "identities_email_idx",
            "columns": [
              "email"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "identities_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "identities_provider_id_provider_unique",
            "columns": [
              "provider_id",
              "provider"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "identities_user_id_idx",
            "columns": [
              "user_id"
            ],
            "unique": false,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "instances",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "uuid",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "raw_base_config",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "instances_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "mfa_amr_claims",
        "columns": [
          {
            "name": "session_id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "sessions",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "authentication_method",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "session_id",
            "authentication_method"
          ]
        ],
        "indexes": [
          {
            "name": "amr_id_pk",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "mfa_amr_claims_session_id_authentication_method_pkey",
            "columns": [
              "session_id",
              "authentication_method"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "mfa_challenges",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "factor_id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "mfa_factors",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "verified_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "ip_address",
            "data_type": "inet",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "otp_code",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "web_authn_session_data",
            "data_type": "jsonb",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "mfa_challenge_created_at_idx",
            "columns": [
              "created_at"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "mfa_challenges_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "mfa_factors",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "user_id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "users",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "friendly_name",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "factor_type",
            "data_type": "USER-DEFINED",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "status",
            "data_type": "USER-DEFINED",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "secret",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "phone",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "last_challenged_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "web_authn_credential",
            "data_type": "jsonb",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "web_authn_aaguid",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "last_webauthn_challenge_data",
            "data_type": "jsonb",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "last_challenged_at"
          ]
        ],
        "indexes": [
          {
            "name": "factor_id_created_at_idx",
            "columns": [
              "user_id",
              "created_at"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "mfa_factors_last_challenged_at_key",
            "columns": [
              "last_challenged_at"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "mfa_factors_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "mfa_factors_user_friendly_name_unique",
            "columns": [
              "friendly_name",
              "user_id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "mfa_factors_user_id_idx",
            "columns": [
              "user_id"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "unique_phone_factor_per_user",
            "columns": [
              "user_id",
              "phone"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "oauth_authorizations",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "authorization_id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "client_id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "oauth_clients",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "user_id",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": {
              "table": "users",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "redirect_uri",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "scope",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "state",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "resource",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "code_challenge",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "code_challenge_method",
            "data_type": "USER-DEFINED",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "response_type",
            "data_type": "USER-DEFINED",
            "nullable": false,
            "default": "'code'::auth.oauth_response_type",
            "references": null
          },
          {
            "name": "status",
            "data_type": "USER-DEFINED",
            "nullable": false,
            "default": "'pending'::auth.oauth_authorization_status",
            "references": null
          },
          {
            "name": "authorization_code",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "expires_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "(now() + '00:03:00'::interval)",
            "references": null
          },
          {
            "name": "approved_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "nonce",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "authorization_code"
          ],
          [
            "authorization_id"
          ]
        ],
        "indexes": [
          {
            "name": "oauth_auth_pending_exp_idx",
            "columns": [
              "expires_at"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "oauth_authorizations_authorization_code_key",
            "columns": [
              "authorization_code"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "oauth_authorizations_authorization_id_key",
            "columns": [
              "authorization_id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "oauth_authorizations_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": false,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "oauth_client_states",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "provider_type",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "code_verifier",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "idx_oauth_client_states_created_at",
            "columns": [
              "created_at"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "oauth_client_states_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": false,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "oauth_clients",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "client_secret_hash",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "registration_type",
            "data_type": "USER-DEFINED",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "redirect_uris",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "grant_types",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "client_name",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "client_uri",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "logo_uri",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "deleted_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "client_type",
            "data_type": "USER-DEFINED",
            "nullable": false,
            "default": "'confidential'::auth.oauth_client_type",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "oauth_clients_deleted_at_idx",
            "columns": [
              "deleted_at"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "oauth_clients_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": false,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "oauth_consents",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "user_id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "users",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "client_id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "oauth_clients",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "scopes",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "granted_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "revoked_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "user_id",
            "client_id"
          ]
        ],
        "indexes": [
          {
            "name": "oauth_consents_active_client_idx",
            "columns": [
              "client_id"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "oauth_consents_active_user_client_idx",
            "columns": [
              "user_id",
              "client_id"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "oauth_consents_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "oauth_consents_user_client_unique",
            "columns": [
              "user_id",
              "client_id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "oauth_consents_user_order_idx",
            "columns": [
              "user_id",
              "granted_at"
            ],
            "unique": false,
            "method": "btree"
          }
        ],
        "rls_enabled": false,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "one_time_tokens",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "user_id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "users",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "token_type",
            "data_type": "USER-DEFINED",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "token_hash",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "relates_to",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp without time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp without time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "one_time_tokens_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "one_time_tokens_relates_to_hash_idx",
            "columns": [
              "relates_to"
            ],
            "unique": false,
            "method": "hash"
          },
          {
            "name": "one_time_tokens_token_hash_hash_idx",
            "columns": [
              "token_hash"
            ],
            "unique": false,
            "method": "hash"
          },
          {
            "name": "one_time_tokens_user_id_token_type_key",
            "columns": [
              "user_id",
              "token_type"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "refresh_tokens",
        "columns": [
          {
            "name": "instance_id",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "id",
            "data_type": "bigint",
            "nullable": false,
            "default": "nextval('auth.refresh_tokens_id_seq'::regclass)",
            "references": null
          },
          {
            "name": "token",
            "data_type": "character varying",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "user_id",
            "data_type": "character varying",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "revoked",
            "data_type": "boolean",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "parent",
            "data_type": "character varying",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "session_id",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": {
              "table": "sessions",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "token"
          ]
        ],
        "indexes": [
          {
            "name": "refresh_tokens_instance_id_idx",
            "columns": [
              "instance_id"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "refresh_tokens_instance_id_user_id_idx",
            "columns": [
              "instance_id",
              "user_id"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "refresh_tokens_parent_idx",
            "columns": [
              "parent"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "refresh_tokens_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "refresh_tokens_session_id_revoked_idx",
            "columns": [
              "session_id",
              "revoked"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "refresh_tokens_token_unique",
            "columns": [
              "token"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "refresh_tokens_updated_at_idx",
            "columns": [
              "updated_at"
            ],
            "unique": false,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "saml_providers",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "sso_provider_id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "sso_providers",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "entity_id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "metadata_xml",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "metadata_url",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "attribute_mapping",
            "data_type": "jsonb",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "name_id_format",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "entity_id"
          ]
        ],
        "indexes": [
          {
            "name": "saml_providers_entity_id_key",
            "columns": [
              "entity_id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "saml_providers_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "saml_providers_sso_provider_id_idx",
            "columns": [
              "sso_provider_id"
            ],
            "unique": false,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "saml_relay_states",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "sso_provider_id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "sso_providers",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "request_id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "for_email",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "redirect_to",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "flow_state_id",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": {
              "table": "flow_state",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "saml_relay_states_created_at_idx",
            "columns": [
              "created_at"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "saml_relay_states_for_email_idx",
            "columns": [
              "for_email"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "saml_relay_states_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "saml_relay_states_sso_provider_id_idx",
            "columns": [
              "sso_provider_id"
            ],
            "unique": false,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "schema_migrations",
        "columns": [
          {
            "name": "version",
            "data_type": "character varying",
            "nullable": false,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "version"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "schema_migrations_pkey",
            "columns": [
              "version"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "sessions",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "user_id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "users",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "factor_id",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "aal",
            "data_type": "USER-DEFINED",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "not_after",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "refreshed_at",
            "data_type": "timestamp without time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "user_agent",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "ip",
            "data_type": "inet",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "tag",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "oauth_client_id",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": {
              "table": "oauth_clients",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "refresh_token_hmac_key",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "refresh_token_counter",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "scopes",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "sessions_not_after_idx",
            "columns": [
              "not_after"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "sessions_oauth_client_id_idx",
            "columns": [
              "oauth_client_id"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "sessions_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "sessions_user_id_idx",
            "columns": [
              "user_id"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "user_id_created_at_idx",
            "columns": [
              "user_id",
              "created_at"
            ],
            "unique": false,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "sso_domains",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "sso_provider_id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "sso_providers",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "domain",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "sso_domains_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "sso_domains_sso_provider_id_idx",
            "columns": [
              "sso_provider_id"
            ],
            "unique": false,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "sso_providers",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "resource_id",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "disabled",
            "data_type": "boolean",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "sso_providers_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "sso_providers_resource_id_pattern_idx",
            "columns": [
              "resource_id"
            ],
            "unique": false,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "auth",
        "name": "users",
        "columns": [
          {
            "name": "instance_id",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "aud",
            "data_type": "character varying",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "role",
            "data_type": "character varying",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "email",
            "data_type": "character varying",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "encrypted_password",
            "data_type": "character varying",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "email_confirmed_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "invited_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "confirmation_token",
            "data_type": "character varying",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "confirmation_sent_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "recovery_token",
            "data_type": "character varying",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "recovery_sent_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "email_change_token_new",
            "data_type": "character varying",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "email_change",
            "data_type": "character varying",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "email_change_sent_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "last_sign_in_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "raw_app_meta_data",
            "data_type": "jsonb",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "raw_user_meta_data",
            "data_type": "jsonb",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "is_super_admin",
            "data_type": "boolean",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "phone",
            "data_type": "text",
            "nullable": true,
            "default": "NULL::character varying",
            "references": null
          },
          {
            "name": "phone_confirmed_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "phone_change",
            "data_type": "text",
            "nullable": true,
            "default": "''::character varying",
            "references": null
          },
          {
            "name": "phone_change_token",
            "data_type": "character varying",
            "nullable": true,
            "default": "''::character varying",
            "references": null
          },
          {
            "name": "phone_change_sent_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "confirmed_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "email_change_token_current",
            "data_type": "character varying",
            "nullable": true,
            "default": "''::character varying",
            "references": null
          },
          {
            "name": "email_change_confirm_status",
            "data_type": "smallint",
            "nullable": true,
            "default": "0",
            "references": null
          },
          {
            "name": "banned_until",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "reauthentication_token",
            "data_type": "character varying",
            "nullable": true,
            "default": "''::character varying",
            "references": null
          },
          {
            "name": "reauthentication_sent_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "is_sso_user",
            "data_type": "boolean",
            "nullable": false,
            "default": "false",
            "references": null
          },
          {
            "name": "deleted_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "is_anonymous",
            "data_type": "boolean",
            "nullable": false,
            "default": "false",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "phone"
          ]
        ],
        "indexes": [
          {
            "name": "confirmation_token_idx",
            "columns": [
              "confirmation_token"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "email_change_token_current_idx",
            "columns": [
              "email_change_token_current"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "email_change_token_new_idx",
            "columns": [
              "email_change_token_new"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "reauthentication_token_idx",
            "columns": [
              "reauthentication_token"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "recovery_token_idx",
            "columns": [
              "recovery_token"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "users_email_partial_key",
            "columns": [
              "email"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "users_instance_id_email_idx",
            "columns": [
              "instance_id"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "users_instance_id_idx",
            "columns": [
              "instance_id"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "users_is_anonymous_idx",
            "columns": [
              "is_anonymous"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "users_phone_key",
            "columns": [
              "phone"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "users_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "extensions",
        "name": "pg_stat_statements",
        "columns": [
          {
            "name": "userid",
            "data_type": "oid",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "dbid",
            "data_type": "oid",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "toplevel",
            "data_type": "boolean",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "queryid",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "query",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "plans",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "total_plan_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "min_plan_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "max_plan_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "mean_plan_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "stddev_plan_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "calls",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "total_exec_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "min_exec_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "max_exec_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "mean_exec_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "stddev_exec_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "rows",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "shared_blks_hit",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "shared_blks_read",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "shared_blks_dirtied",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "shared_blks_written",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "local_blks_hit",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "local_blks_read",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "local_blks_dirtied",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "local_blks_written",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "temp_blks_read",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "temp_blks_written",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "shared_blk_read_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "shared_blk_write_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "local_blk_read_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "local_blk_write_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "temp_blk_read_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "temp_blk_write_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "wal_records",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "wal_fpi",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "wal_bytes",
            "data_type": "numeric",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "jit_functions",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "jit_generation_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "jit_inlining_count",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "jit_inlining_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "jit_optimization_count",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "jit_optimization_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "jit_emission_count",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "jit_emission_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "jit_deform_count",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "jit_deform_time",
            "data_type": "double precision",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "stats_since",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "minmax_stats_since",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "unknown"
        ],
        "uniques": [],
        "indexes": [],
        "rls_enabled": false,
        "policies": []
      },
      {
        "schema": "extensions",
        "name": "pg_stat_statements_info",
        "columns": [
          {
            "name": "dealloc",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "stats_reset",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "unknown"
        ],
        "uniques": [],
        "indexes": [],
        "rls_enabled": false,
        "policies": []
      },
      {
        "schema": "public",
        "name": "companies",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          },
          {
            "name": "companyCode",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "companyName",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "isDisabled",
            "data_type": "boolean",
            "nullable": false,
            "default": "false",
            "references": null
          },
          {
            "name": "supportEnabled",
            "data_type": "boolean",
            "nullable": false,
            "default": "false",
            "references": null
          },
          {
            "name": "createdAt",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "company_code",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "name",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "company_name",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "is_disabled",
            "data_type": "boolean",
            "nullable": false,
            "default": "false",
            "references": null
          },
          {
            "name": "support_enabled",
            "data_type": "boolean",
            "nullable": false,
            "default": "false",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "company_code"
          ],
          [
            "companyCode"
          ]
        ],
        "indexes": [
          {
            "name": "companies_company_code_idx",
            "columns": [
              "companyCode"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "companies_company_code_key",
            "columns": [
              "company_code"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "companies_company_code_unique",
            "columns": [
              "companyCode"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "companies_company_code_uq_v2",
            "columns": [
              "company_code"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "companies_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": [
          {
            "name": "companies_platform_admin_all",
            "command": "ALL",
            "roles": [
              "authenticated"
            ],
            "using": "is_platform_admin()",
            "check": "is_platform_admin()"
          },
          {
            "name": "companies_service_role_all",
            "command": "ALL",
            "roles": [
              "service_role"
            ],
            "using": "true",
            "check": "true"
          },
          {
            "name": "companies_tenant_read_own",
            "command": "SELECT",
            "roles": [
              "authenticated"
            ],
            "using": "(company_code = current_company_code())",
            "check": null
          }
        ]
      },
      {
        "schema": "public",
        "name": "credential_reset_requests",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          },
          {
            "name": "company_code",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": {
              "table": "users",
              "column": "company_code",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "requested_by_user_id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "users",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "target_user_id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "users",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "request_type",
            "data_type": "USER-DEFINED",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "status",
            "data_type": "USER-DEFINED",
            "nullable": false,
            "default": "'pending'::credential_reset_request_status",
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "resolved_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "credential_reset_requests_company_code_idx",
            "columns": [
              "company_code"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "credential_reset_requests_company_code_status_idx",
            "columns": [
              "company_code",
              "status"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "credential_reset_requests_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "credential_reset_requests_target_user_id_idx",
            "columns": [
              "target_user_id"
            ],
            "unique": false,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": [
          {
            "name": "credential_reset_requests_employee_insert_self",
            "command": "INSERT",
            "roles": [
              "authenticated"
            ],
            "using": null,
            "check": "((company_code = current_company_code()) AND (current_user_role() = 'employee'::user_role) AND (requested_by_user_id = auth.uid()) AND (target_user_id = auth.uid()) AND (status = 'pending'::credential_reset_request_status))"
          },
          {
            "name": "credential_reset_requests_employee_read_self",
            "command": "SELECT",
            "roles": [
              "authenticated"
            ],
            "using": "((company_code = current_company_code()) AND ((requested_by_user_id = auth.uid()) OR (target_user_id = auth.uid())))",
            "check": null
          },
          {
            "name": "credential_reset_requests_manager_insert",
            "command": "INSERT",
            "roles": [
              "authenticated"
            ],
            "using": null,
            "check": "((company_code = current_company_code()) AND is_manager() AND (requested_by_user_id = auth.uid()) AND (status = 'pending'::credential_reset_request_status))"
          },
          {
            "name": "credential_reset_requests_manager_read_company",
            "command": "SELECT",
            "roles": [
              "authenticated"
            ],
            "using": "(is_manager() AND (company_code = current_company_code()))",
            "check": null
          },
          {
            "name": "credential_reset_requests_manager_update_company",
            "command": "UPDATE",
            "roles": [
              "authenticated"
            ],
            "using": "(is_manager() AND (company_code = current_company_code()))",
            "check": "(is_manager() AND (company_code = current_company_code()))"
          },
          {
            "name": "credential_reset_requests_platform_admin_all",
            "command": "ALL",
            "roles": [
              "authenticated"
            ],
            "using": "is_platform_admin()",
            "check": "is_platform_admin()"
          },
          {
            "name": "credential_reset_requests_service_role_all",
            "command": "ALL",
            "roles": [
              "service_role"
            ],
            "using": "true",
            "check": "true"
          }
        ]
      },
      {
        "schema": "public",
        "name": "crew_members",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          },
          {
            "name": "companyCode",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": {
              "table": "employees",
              "column": "companyCode",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "crewId",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "crews",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "employeeId",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "employees",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "createdAt",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "company_code",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "crew_id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "employee_id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "crew_id",
            "employee_id"
          ],
          [
            "companyCode",
            "crewId",
            "employeeId"
          ]
        ],
        "indexes": [
          {
            "name": "crew_members_company_code_crew_id_idx",
            "columns": [
              "companyCode",
              "crewId"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "crew_members_company_code_employee_id_idx",
            "columns": [
              "companyCode",
              "employeeId"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "crew_members_company_code_idx",
            "columns": [
              "companyCode"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "crew_members_crew_id_employee_id_key",
            "columns": [
              "crew_id",
              "employee_id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "crew_members_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "crew_members_unique_membership",
            "columns": [
              "companyCode",
              "crewId",
              "employeeId"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": [
          {
            "name": "crew_members_employee_read_self_membership",
            "command": "SELECT",
            "roles": [
              "authenticated"
            ],
            "using": "((\"current_role\"() = 'employee'::user_role) AND current_user_active() AND current_company_is_active() AND (\"companyCode\" = current_company_code()) AND (\"employeeId\" = current_employee_id()))",
            "check": null
          },
          {
            "name": "crew_members_manager_crud",
            "command": "ALL",
            "roles": [
              "authenticated"
            ],
            "using": "((\"current_role\"() = 'manager'::user_role) AND current_user_active() AND current_company_is_active() AND (\"companyCode\" = current_company_code()))",
            "check": "((\"current_role\"() = 'manager'::user_role) AND current_user_active() AND current_company_is_active() AND (\"companyCode\" = current_company_code()))"
          },
          {
            "name": "crew_members_service_role_all",
            "command": "ALL",
            "roles": [
              "service_role"
            ],
            "using": "true",
            "check": "true"
          }
        ]
      },
      {
        "schema": "public",
        "name": "crews",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          },
          {
            "name": "companyCode",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "name",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "active",
            "data_type": "boolean",
            "nullable": false,
            "default": "true",
            "references": null
          },
          {
            "name": "createdAt",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "updatedAt",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "company_code",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "companyCode",
            "id"
          ]
        ],
        "indexes": [
          {
            "name": "crews_company_code_id_unique",
            "columns": [
              "companyCode",
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "crews_company_code_idx",
            "columns": [
              "companyCode"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "crews_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": [
          {
            "name": "crews_employee_read_memberships",
            "command": "SELECT",
            "roles": [
              "authenticated"
            ],
            "using": "((\"current_role\"() = 'employee'::user_role) AND current_user_active() AND current_company_is_active() AND (\"companyCode\" = current_company_code()) AND (EXISTS ( SELECT 1    FROM crew_members cm   WHERE ((cm.\"companyCode\" = crews.\"companyCode\") AND (cm.\"crewId\" = crews.id) AND (cm.\"employeeId\" = current_employee_id())))))",
            "check": null
          },
          {
            "name": "crews_manager_crud",
            "command": "ALL",
            "roles": [
              "authenticated"
            ],
            "using": "((\"current_role\"() = 'manager'::user_role) AND current_user_active() AND current_company_is_active() AND (\"companyCode\" = current_company_code()))",
            "check": "((\"current_role\"() = 'manager'::user_role) AND current_user_active() AND current_company_is_active() AND (\"companyCode\" = current_company_code()))"
          },
          {
            "name": "crews_service_role_all",
            "command": "ALL",
            "roles": [
              "service_role"
            ],
            "using": "true",
            "check": "true"
          }
        ]
      },
      {
        "schema": "public",
        "name": "employees",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          },
          {
            "name": "companyCode",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "name",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "contact",
            "data_type": "text",
            "nullable": false,
            "default": "''::text",
            "references": null
          },
          {
            "name": "active",
            "data_type": "boolean",
            "nullable": false,
            "default": "true",
            "references": null
          },
          {
            "name": "createdAt",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "updatedAt",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "company_code",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "companyCode",
            "id"
          ]
        ],
        "indexes": [
          {
            "name": "employees_company_code_active_idx",
            "columns": [
              "companyCode",
              "active"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "employees_company_code_id_unique",
            "columns": [
              "companyCode",
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "employees_company_code_id_uq_v2",
            "columns": [
              "company_code",
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "employees_company_code_idx",
            "columns": [
              "companyCode"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "employees_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": [
          {
            "name": "employees_employee_read_self",
            "command": "SELECT",
            "roles": [
              "authenticated"
            ],
            "using": "((id = current_employee_id()) AND (company_code = current_company_code()))",
            "check": null
          },
          {
            "name": "employees_manager_crud_company",
            "command": "ALL",
            "roles": [
              "authenticated"
            ],
            "using": "(is_manager() AND (company_code = current_company_code()))",
            "check": "(is_manager() AND (company_code = current_company_code()))"
          },
          {
            "name": "employees_platform_admin_all",
            "command": "ALL",
            "roles": [
              "authenticated"
            ],
            "using": "is_platform_admin()",
            "check": "is_platform_admin()"
          },
          {
            "name": "employees_service_role_all",
            "command": "ALL",
            "roles": [
              "service_role"
            ],
            "using": "true",
            "check": "true"
          }
        ]
      },
      {
        "schema": "public",
        "name": "job_sites",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          },
          {
            "name": "companyCode",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "name",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "address",
            "data_type": "text",
            "nullable": false,
            "default": "''::text",
            "references": null
          },
          {
            "name": "active",
            "data_type": "boolean",
            "nullable": false,
            "default": "true",
            "references": null
          },
          {
            "name": "createdAt",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "updatedAt",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "company_code",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "companyCode",
            "id"
          ]
        ],
        "indexes": [
          {
            "name": "job_sites_company_code_id_uq_v2",
            "columns": [
              "company_code",
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "locations_company_code_id_unique",
            "columns": [
              "companyCode",
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "locations_company_code_idx",
            "columns": [
              "companyCode"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "locations_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": [
          {
            "name": "job_sites_employee_read_company",
            "command": "SELECT",
            "roles": [
              "authenticated"
            ],
            "using": "(company_code = current_company_code())",
            "check": null
          },
          {
            "name": "job_sites_manager_crud_company",
            "command": "ALL",
            "roles": [
              "authenticated"
            ],
            "using": "(is_manager() AND (company_code = current_company_code()))",
            "check": "(is_manager() AND (company_code = current_company_code()))"
          },
          {
            "name": "job_sites_platform_admin_all",
            "command": "ALL",
            "roles": [
              "authenticated"
            ],
            "using": "is_platform_admin()",
            "check": "is_platform_admin()"
          },
          {
            "name": "job_sites_service_role_all",
            "command": "ALL",
            "roles": [
              "service_role"
            ],
            "using": "true",
            "check": "true"
          }
        ]
      },
      {
        "schema": "public",
        "name": "job_types",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          },
          {
            "name": "companyCode",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "name",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "active",
            "data_type": "boolean",
            "nullable": false,
            "default": "true",
            "references": null
          },
          {
            "name": "createdAt",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "updatedAt",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "company_code",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "companyCode",
            "id"
          ]
        ],
        "indexes": [
          {
            "name": "job_types_company_code_id_unique",
            "columns": [
              "companyCode",
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "job_types_company_code_idx",
            "columns": [
              "companyCode"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "job_types_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": [
          {
            "name": "job_types_employee_read_company",
            "command": "SELECT",
            "roles": [
              "authenticated"
            ],
            "using": "((\"current_role\"() = 'employee'::user_role) AND current_user_active() AND current_company_is_active() AND (\"companyCode\" = current_company_code()))",
            "check": null
          },
          {
            "name": "job_types_manager_crud",
            "command": "ALL",
            "roles": [
              "authenticated"
            ],
            "using": "((\"current_role\"() = 'manager'::user_role) AND current_user_active() AND current_company_is_active() AND (\"companyCode\" = current_company_code()))",
            "check": "((\"current_role\"() = 'manager'::user_role) AND current_user_active() AND current_company_is_active() AND (\"companyCode\" = current_company_code()))"
          },
          {
            "name": "job_types_service_role_all",
            "command": "ALL",
            "roles": [
              "service_role"
            ],
            "using": "true",
            "check": "true"
          }
        ]
      },
      {
        "schema": "public",
        "name": "locations",
        "columns": [
          {
            "name": "id",
            "data_type": "text",
            "nullable": false,
            "default": "(gen_random_uuid())::text",
            "references": null
          },
          {
            "name": "company_code",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "name",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "address",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "active",
            "data_type": "boolean",
            "nullable": false,
            "default": "true",
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "locations_pkey1",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "public",
        "name": "platform_admin_reset_tokens",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          },
          {
            "name": "user_id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "users",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "token_hash",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "expires_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "used_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "created_by",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "token_hash"
          ]
        ],
        "indexes": [
          {
            "name": "platform_admin_reset_tokens_expires_at_idx",
            "columns": [
              "expires_at"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "platform_admin_reset_tokens_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "platform_admin_reset_tokens_token_hash_key",
            "columns": [
              "token_hash"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "platform_admin_reset_tokens_user_id_idx",
            "columns": [
              "user_id"
            ],
            "unique": false,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": [
          {
            "name": "platform_admin_reset_tokens_internal_only",
            "command": "ALL",
            "roles": [
              "public"
            ],
            "using": "(CURRENT_USER = ANY (ARRAY['postgres'::name, 'supabase_admin'::name]))",
            "check": "(CURRENT_USER = ANY (ARRAY['postgres'::name, 'supabase_admin'::name]))"
          }
        ]
      },
      {
        "schema": "public",
        "name": "requests",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          },
          {
            "name": "companyCode",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "type",
            "data_type": "USER-DEFINED",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "status",
            "data_type": "USER-DEFINED",
            "nullable": false,
            "default": "'pending'::request_status",
            "references": null
          },
          {
            "name": "requesterUserId",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "users",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "targetUserId",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "users",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "proposedUsername",
            "data_type": "text",
            "nullable": false,
            "default": "''::text",
            "references": null
          },
          {
            "name": "proposedPin",
            "data_type": "text",
            "nullable": false,
            "default": "''::text",
            "references": null
          },
          {
            "name": "createdAt",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "handledAt",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "handledBy",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": {
              "table": "users",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "NO ACTION"
            }
          },
          {
            "name": "decisionNote",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "company_code",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "requester_user_id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "target_user_id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "proposed_username",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "proposed_pin",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "handled_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "handled_by",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "decision_note",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "requests_company_code_idx",
            "columns": [
              "companyCode"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "requests_company_code_status_idx",
            "columns": [
              "companyCode",
              "status"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "requests_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "requests_target_user_idx",
            "columns": [
              "targetUserId"
            ],
            "unique": false,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": [
          {
            "name": "requests_employee_insert_self",
            "command": "INSERT",
            "roles": [
              "authenticated"
            ],
            "using": null,
            "check": "((\"current_role\"() = 'employee'::user_role) AND current_user_active() AND current_company_is_active() AND (\"companyCode\" = current_company_code()) AND (type = 'employee_change_credentials'::request_type) AND (status = 'pending'::request_status) AND (\"requesterUserId\" = auth.uid()) AND (\"targetUserId\" = auth.uid()))"
          },
          {
            "name": "requests_employee_read_self",
            "command": "SELECT",
            "roles": [
              "authenticated"
            ],
            "using": "((\"current_role\"() = 'employee'::user_role) AND current_user_active() AND current_company_is_active() AND (\"companyCode\" = current_company_code()) AND ((\"requesterUserId\" = auth.uid()) OR (\"targetUserId\" = auth.uid())))",
            "check": null
          },
          {
            "name": "requests_manager_insert_self",
            "command": "INSERT",
            "roles": [
              "authenticated"
            ],
            "using": null,
            "check": "((\"current_role\"() = 'manager'::user_role) AND current_user_active() AND current_company_is_active() AND (\"companyCode\" = current_company_code()) AND (type = 'manager_change_credentials'::request_type) AND (status = 'pending'::request_status) AND (\"requesterUserId\" = auth.uid()) AND (\"targetUserId\" = auth.uid()))"
          },
          {
            "name": "requests_manager_read_company",
            "command": "SELECT",
            "roles": [
              "authenticated"
            ],
            "using": "((\"current_role\"() = 'manager'::user_role) AND current_user_active() AND current_company_is_active() AND (\"companyCode\" = current_company_code()) AND ((type = 'employee_change_credentials'::request_type) OR (\"requesterUserId\" = auth.uid()) OR (\"targetUserId\" = auth.uid())))",
            "check": null
          },
          {
            "name": "requests_platform_admin_insert_self",
            "command": "INSERT",
            "roles": [
              "authenticated"
            ],
            "using": null,
            "check": "((\"current_role\"() = 'platform_admin'::user_role) AND (\"companyCode\" = 'PLATFORM'::text) AND (type = 'admin_change_credentials'::request_type) AND (status = 'pending'::request_status) AND (\"requesterUserId\" = auth.uid()) AND (\"targetUserId\" = auth.uid()))"
          },
          {
            "name": "requests_platform_admin_read_all",
            "command": "SELECT",
            "roles": [
              "authenticated"
            ],
            "using": "((\"current_role\"() = 'platform_admin'::user_role) AND current_user_active() AND ((type = 'manager_change_credentials'::request_type) OR ((type = 'admin_change_credentials'::request_type) AND (\"companyCode\" = 'PLATFORM'::text))))",
            "check": null
          },
          {
            "name": "requests_service_role_all",
            "command": "ALL",
            "roles": [
              "service_role"
            ],
            "using": "true",
            "check": "true"
          }
        ]
      },
      {
        "schema": "public",
        "name": "schedules",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          },
          {
            "name": "company_code",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": {
              "table": "companies",
              "column": "company_code",
              "on_update": "NO ACTION",
              "on_delete": "NO ACTION"
            }
          },
          {
            "name": "week_start_date",
            "data_type": "date",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "company_code",
            "id"
          ],
          [
            "company_code",
            "week_start_date"
          ]
        ],
        "indexes": [
          {
            "name": "schedules_company_code_id_unique",
            "columns": [
              "company_code",
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "schedules_company_code_idx",
            "columns": [
              "company_code"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "schedules_company_code_week_start_date_idx",
            "columns": [
              "company_code",
              "week_start_date"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "schedules_company_week_unique",
            "columns": [
              "company_code",
              "week_start_date"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "schedules_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": [
          {
            "name": "schedules_employee_read_company",
            "command": "SELECT",
            "roles": [
              "authenticated"
            ],
            "using": "(company_code = current_company_code())",
            "check": null
          },
          {
            "name": "schedules_manager_crud_company",
            "command": "ALL",
            "roles": [
              "authenticated"
            ],
            "using": "(is_manager() AND (company_code = current_company_code()))",
            "check": "(is_manager() AND (company_code = current_company_code()))"
          },
          {
            "name": "schedules_platform_admin_all",
            "command": "ALL",
            "roles": [
              "authenticated"
            ],
            "using": "is_platform_admin()",
            "check": "is_platform_admin()"
          },
          {
            "name": "schedules_service_role_all",
            "command": "ALL",
            "roles": [
              "service_role"
            ],
            "using": "true",
            "check": "true"
          }
        ]
      },
      {
        "schema": "public",
        "name": "shift_jobs",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          },
          {
            "name": "companyCode",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": {
              "table": "shifts",
              "column": "companyCode",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "shiftId",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "shifts",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "jobTypeId",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "job_types",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "RESTRICT"
            }
          },
          {
            "name": "createdAt",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "company_code",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "shift_id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "job_type_id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "shift_id",
            "job_type_id"
          ],
          [
            "companyCode",
            "shiftId",
            "jobTypeId"
          ]
        ],
        "indexes": [
          {
            "name": "shift_jobs_company_code_idx",
            "columns": [
              "companyCode"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "shift_jobs_company_code_shift_id_idx",
            "columns": [
              "companyCode",
              "shiftId"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "shift_jobs_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "shift_jobs_shift_id_job_type_id_key",
            "columns": [
              "shift_id",
              "job_type_id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "shift_jobs_unique_per_shift",
            "columns": [
              "companyCode",
              "shiftId",
              "jobTypeId"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": [
          {
            "name": "shift_jobs_employee_read_allowed_shifts",
            "command": "SELECT",
            "roles": [
              "authenticated"
            ],
            "using": "((\"current_role\"() = 'employee'::user_role) AND current_user_active() AND current_company_is_active() AND (\"companyCode\" = current_company_code()) AND (EXISTS ( SELECT 1    FROM shifts s   WHERE ((s.\"companyCode\" = shift_jobs.\"companyCode\") AND (s.id = shift_jobs.\"shiftId\") AND ((s.\"empId\" = current_employee_id()) OR (EXISTS ( SELECT 1            FROM crew_members cm           WHERE ((cm.\"companyCode\" = s.\"companyCode\") AND (cm.\"crewId\" = s.\"crewId\") AND (cm.\"employeeId\" = current_employee_id())))))))))",
            "check": null
          },
          {
            "name": "shift_jobs_manager_crud",
            "command": "ALL",
            "roles": [
              "authenticated"
            ],
            "using": "((\"current_role\"() = 'manager'::user_role) AND current_user_active() AND current_company_is_active() AND (\"companyCode\" = current_company_code()))",
            "check": "((\"current_role\"() = 'manager'::user_role) AND current_user_active() AND current_company_is_active() AND (\"companyCode\" = current_company_code()))"
          },
          {
            "name": "shift_jobs_service_role_all",
            "command": "ALL",
            "roles": [
              "service_role"
            ],
            "using": "true",
            "check": "true"
          }
        ]
      },
      {
        "schema": "public",
        "name": "shifts",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          },
          {
            "name": "companyCode",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": {
              "table": "job_sites",
              "column": "companyCode",
              "on_update": "NO ACTION",
              "on_delete": "NO ACTION"
            }
          },
          {
            "name": "date",
            "data_type": "date",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "start",
            "data_type": "time without time zone",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "end",
            "data_type": "time without time zone",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "notes",
            "data_type": "text",
            "nullable": false,
            "default": "''::text",
            "references": null
          },
          {
            "name": "locId",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "job_sites",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "NO ACTION"
            }
          },
          {
            "name": "empId",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": {
              "table": "employees",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "NO ACTION"
            }
          },
          {
            "name": "crewId",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": {
              "table": "crews",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "NO ACTION"
            }
          },
          {
            "name": "createdAt",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "updatedAt",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "company_code",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": {
              "table": "schedules",
              "column": "company_code",
              "on_update": "NO ACTION",
              "on_delete": "RESTRICT"
            }
          },
          {
            "name": "schedule_id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "schedules",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "RESTRICT"
            }
          },
          {
            "name": "employee_id",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "job_site_id",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "start_time",
            "data_type": "timestamp without time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "end_time",
            "data_type": "timestamp without time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "loc_id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "emp_id",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "crew_id",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "companyCode",
            "id"
          ]
        ],
        "indexes": [
          {
            "name": "shifts_company_code_crew_date_idx",
            "columns": [
              "companyCode",
              "crewId",
              "date"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "shifts_company_code_date_idx",
            "columns": [
              "companyCode",
              "date"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "shifts_company_code_emp_date_idx",
            "columns": [
              "companyCode",
              "empId",
              "date"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "shifts_company_code_id_unique",
            "columns": [
              "companyCode",
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "shifts_company_code_idx",
            "columns": [
              "companyCode"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "shifts_company_code_schedule_id_idx",
            "columns": [
              "company_code",
              "schedule_id"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "shifts_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": [
          {
            "name": "shifts_employee_read_own",
            "command": "SELECT",
            "roles": [
              "authenticated"
            ],
            "using": "((company_code = current_company_code()) AND (employee_id IS NOT NULL) AND (employee_id = current_employee_id()))",
            "check": null
          },
          {
            "name": "shifts_manager_crud_company",
            "command": "ALL",
            "roles": [
              "authenticated"
            ],
            "using": "(is_manager() AND (company_code = current_company_code()))",
            "check": "(is_manager() AND (company_code = current_company_code()))"
          },
          {
            "name": "shifts_platform_admin_all",
            "command": "ALL",
            "roles": [
              "authenticated"
            ],
            "using": "is_platform_admin()",
            "check": "is_platform_admin()"
          },
          {
            "name": "shifts_service_role_all",
            "command": "ALL",
            "roles": [
              "service_role"
            ],
            "using": "true",
            "check": "true"
          }
        ]
      },
      {
        "schema": "public",
        "name": "users",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": {
              "table": "users",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "companyCode",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": {
              "table": "employees",
              "column": "companyCode",
              "on_update": "NO ACTION",
              "on_delete": "NO ACTION"
            }
          },
          {
            "name": "username",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "pinHash",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "role",
            "data_type": "USER-DEFINED",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "employeeId",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": {
              "table": "employees",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "NO ACTION"
            }
          },
          {
            "name": "active",
            "data_type": "boolean",
            "nullable": false,
            "default": "true",
            "references": null
          },
          {
            "name": "createdAt",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "updatedAt",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "company_code",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": {
              "table": "companies",
              "column": "company_code",
              "on_update": "NO ACTION",
              "on_delete": "RESTRICT"
            }
          },
          {
            "name": "pin_hash",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "force_pin_change",
            "data_type": "boolean",
            "nullable": false,
            "default": "false",
            "references": null
          },
          {
            "name": "employee_id",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "company_code",
            "username"
          ],
          [
            "companyCode",
            "username"
          ]
        ],
        "indexes": [
          {
            "name": "users_company_code_employee_id_idx",
            "columns": [
              "companyCode",
              "employeeId"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "users_company_code_id_uq_v2",
            "columns": [
              "company_code",
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "users_company_code_idx",
            "columns": [
              "companyCode"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "users_company_code_role_idx",
            "columns": [
              "companyCode",
              "role"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "users_company_code_username_key",
            "columns": [
              "company_code",
              "username"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "users_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "users_unique_username_per_company",
            "columns": [
              "companyCode",
              "username"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": [
          {
            "name": "users_employee_read_self",
            "command": "SELECT",
            "roles": [
              "authenticated"
            ],
            "using": "(id = auth.uid())",
            "check": null
          },
          {
            "name": "users_manager_read_company",
            "command": "SELECT",
            "roles": [
              "authenticated"
            ],
            "using": "(is_manager() AND (company_code = current_company_code()))",
            "check": null
          },
          {
            "name": "users_platform_admin_read_all",
            "command": "SELECT",
            "roles": [
              "authenticated"
            ],
            "using": "is_platform_admin()",
            "check": null
          },
          {
            "name": "users_service_role_all",
            "command": "ALL",
            "roles": [
              "service_role"
            ],
            "using": "true",
            "check": "true"
          }
        ]
      },
      {
        "schema": "realtime",
        "name": "messages",
        "columns": [
          {
            "name": "topic",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "extension",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "payload",
            "data_type": "jsonb",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "event",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "private",
            "data_type": "boolean",
            "nullable": true,
            "default": "false",
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp without time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "inserted_at",
            "data_type": "timestamp without time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          }
        ],
        "primary_key": [
          "id",
          "inserted_at"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "messages_inserted_at_topic_index",
            "columns": [
              "inserted_at",
              "topic"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "messages_pkey",
            "columns": [
              "id",
              "inserted_at"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "realtime",
        "name": "schema_migrations",
        "columns": [
          {
            "name": "version",
            "data_type": "bigint",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "inserted_at",
            "data_type": "timestamp without time zone",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "version"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "schema_migrations_pkey",
            "columns": [
              "version"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": false,
        "policies": []
      },
      {
        "schema": "realtime",
        "name": "subscription",
        "columns": [
          {
            "name": "id",
            "data_type": "bigint",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "subscription_id",
            "data_type": "uuid",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "entity",
            "data_type": "regclass",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "filters",
            "data_type": "ARRAY",
            "nullable": false,
            "default": "'{}'::realtime.user_defined_filter[]",
            "references": null
          },
          {
            "name": "claims",
            "data_type": "jsonb",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "claims_role",
            "data_type": "regrole",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp without time zone",
            "nullable": false,
            "default": "timezone('utc'::text, now())",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "ix_realtime_subscription_entity",
            "columns": [
              "entity"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "pk_subscription",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "subscription_subscription_id_entity_filters_key",
            "columns": [
              "subscription_id",
              "entity",
              "filters"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": false,
        "policies": []
      },
      {
        "schema": "storage",
        "name": "buckets",
        "columns": [
          {
            "name": "id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "name",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "owner",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": "now()",
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": "now()",
            "references": null
          },
          {
            "name": "public",
            "data_type": "boolean",
            "nullable": true,
            "default": "false",
            "references": null
          },
          {
            "name": "avif_autodetection",
            "data_type": "boolean",
            "nullable": true,
            "default": "false",
            "references": null
          },
          {
            "name": "file_size_limit",
            "data_type": "bigint",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "allowed_mime_types",
            "data_type": "ARRAY",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "owner_id",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "type",
            "data_type": "USER-DEFINED",
            "nullable": false,
            "default": "'STANDARD'::storage.buckettype",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "bname",
            "columns": [
              "name"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "buckets_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "storage",
        "name": "buckets_analytics",
        "columns": [
          {
            "name": "name",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "type",
            "data_type": "USER-DEFINED",
            "nullable": false,
            "default": "'ANALYTICS'::storage.buckettype",
            "references": null
          },
          {
            "name": "format",
            "data_type": "text",
            "nullable": false,
            "default": "'ICEBERG'::text",
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          },
          {
            "name": "deleted_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "buckets_analytics_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "buckets_analytics_unique_name_idx",
            "columns": [
              "name"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "storage",
        "name": "buckets_vectors",
        "columns": [
          {
            "name": "id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "type",
            "data_type": "USER-DEFINED",
            "nullable": false,
            "default": "'VECTOR'::storage.buckettype",
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "buckets_vectors_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "storage",
        "name": "migrations",
        "columns": [
          {
            "name": "id",
            "data_type": "integer",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "name",
            "data_type": "character varying",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "hash",
            "data_type": "character varying",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "executed_at",
            "data_type": "timestamp without time zone",
            "nullable": true,
            "default": "CURRENT_TIMESTAMP",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [
          [
            "name"
          ]
        ],
        "indexes": [
          {
            "name": "migrations_name_key",
            "columns": [
              "name"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "migrations_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "storage",
        "name": "objects",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          },
          {
            "name": "bucket_id",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": {
              "table": "buckets",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "NO ACTION"
            }
          },
          {
            "name": "name",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "owner",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": "now()",
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": "now()",
            "references": null
          },
          {
            "name": "last_accessed_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": "now()",
            "references": null
          },
          {
            "name": "metadata",
            "data_type": "jsonb",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "path_tokens",
            "data_type": "ARRAY",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "version",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "owner_id",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "user_metadata",
            "data_type": "jsonb",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "level",
            "data_type": "integer",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "bucketid_objname",
            "columns": [
              "bucket_id",
              "name"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "idx_name_bucket_level_unique",
            "columns": [
              "name",
              "bucket_id",
              "level"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "idx_objects_bucket_id_name",
            "columns": [
              "bucket_id",
              "name"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "idx_objects_lower_name",
            "columns": [
              "bucket_id",
              "level"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "name_prefix_search",
            "columns": [
              "name"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "objects_bucket_id_level_idx",
            "columns": [
              "bucket_id",
              "level",
              "name"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "objects_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "storage",
        "name": "prefixes",
        "columns": [
          {
            "name": "bucket_id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": {
              "table": "buckets",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "NO ACTION"
            }
          },
          {
            "name": "name",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "level",
            "data_type": "integer",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": "now()",
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": "now()",
            "references": null
          }
        ],
        "primary_key": [
          "bucket_id",
          "level",
          "name"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "idx_prefixes_lower_name",
            "columns": [
              "bucket_id",
              "level"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "prefixes_pkey",
            "columns": [
              "bucket_id",
              "level",
              "name"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "storage",
        "name": "s3_multipart_uploads",
        "columns": [
          {
            "name": "id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "in_progress_size",
            "data_type": "bigint",
            "nullable": false,
            "default": "0",
            "references": null
          },
          {
            "name": "upload_signature",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "bucket_id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": {
              "table": "buckets",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "NO ACTION"
            }
          },
          {
            "name": "key",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "version",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "owner_id",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "user_metadata",
            "data_type": "jsonb",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "idx_multipart_uploads_list",
            "columns": [
              "bucket_id",
              "key",
              "created_at"
            ],
            "unique": false,
            "method": "btree"
          },
          {
            "name": "s3_multipart_uploads_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "storage",
        "name": "s3_multipart_uploads_parts",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          },
          {
            "name": "upload_id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": {
              "table": "s3_multipart_uploads",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "CASCADE"
            }
          },
          {
            "name": "size",
            "data_type": "bigint",
            "nullable": false,
            "default": "0",
            "references": null
          },
          {
            "name": "part_number",
            "data_type": "integer",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "bucket_id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": {
              "table": "buckets",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "NO ACTION"
            }
          },
          {
            "name": "key",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "etag",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "owner_id",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "version",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "s3_multipart_uploads_parts_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "storage",
        "name": "vector_indexes",
        "columns": [
          {
            "name": "id",
            "data_type": "text",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          },
          {
            "name": "name",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "bucket_id",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": {
              "table": "buckets_vectors",
              "column": "id",
              "on_update": "NO ACTION",
              "on_delete": "NO ACTION"
            }
          },
          {
            "name": "data_type",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "dimension",
            "data_type": "integer",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "distance_metric",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "metadata_configuration",
            "data_type": "jsonb",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "now()",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "vector_indexes_name_bucket_id_idx",
            "columns": [
              "name",
              "bucket_id"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "vector_indexes_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": true,
        "policies": []
      },
      {
        "schema": "supabase_migrations",
        "name": "schema_migrations",
        "columns": [
          {
            "name": "version",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "statements",
            "data_type": "ARRAY",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "name",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "version"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "schema_migrations_pkey",
            "columns": [
              "version"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": false,
        "policies": []
      },
      {
        "schema": "vault",
        "name": "decrypted_secrets",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "name",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "description",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "secret",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "decrypted_secret",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "key_id",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "nonce",
            "data_type": "bytea",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": true,
            "default": null,
            "references": null
          }
        ],
        "primary_key": [
          "unknown"
        ],
        "uniques": [],
        "indexes": [],
        "rls_enabled": false,
        "policies": []
      },
      {
        "schema": "vault",
        "name": "secrets",
        "columns": [
          {
            "name": "id",
            "data_type": "uuid",
            "nullable": false,
            "default": "gen_random_uuid()",
            "references": null
          },
          {
            "name": "name",
            "data_type": "text",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "description",
            "data_type": "text",
            "nullable": false,
            "default": "''::text",
            "references": null
          },
          {
            "name": "secret",
            "data_type": "text",
            "nullable": false,
            "default": null,
            "references": null
          },
          {
            "name": "key_id",
            "data_type": "uuid",
            "nullable": true,
            "default": null,
            "references": null
          },
          {
            "name": "nonce",
            "data_type": "bytea",
            "nullable": true,
            "default": "vault._crypto_aead_det_noncegen()",
            "references": null
          },
          {
            "name": "created_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "CURRENT_TIMESTAMP",
            "references": null
          },
          {
            "name": "updated_at",
            "data_type": "timestamp with time zone",
            "nullable": false,
            "default": "CURRENT_TIMESTAMP",
            "references": null
          }
        ],
        "primary_key": [
          "id"
        ],
        "uniques": [],
        "indexes": [
          {
            "name": "secrets_name_idx",
            "columns": [
              "name"
            ],
            "unique": true,
            "method": "btree"
          },
          {
            "name": "secrets_pkey",
            "columns": [
              "id"
            ],
            "unique": true,
            "method": "btree"
          }
        ],
        "rls_enabled": false,
        "policies": []
      }
    ],
    "views": [
      {
        "schema": "extensions",
        "name": "pg_stat_statements",
        "definition": " SELECT userid,     dbid,     toplevel,     queryid,     query,     plans,     total_plan_time,     min_plan_time,     max_plan_time,     mean_plan_time,     stddev_plan_time,     calls,     total_exec_time,     min_exec_time,     max_exec_time,     mean_exec_time,     stddev_exec_time,     rows,     shared_blks_hit,     shared_blks_read,     shared_blks_dirtied,     shared_blks_written,     local_blks_hit,     local_blks_read,     local_blks_dirtied,     local_blks_written,     temp_blks_read,     temp_blks_written,     shared_blk_read_time,     shared_blk_write_time,     local_blk_read_time,     local_blk_write_time,     temp_blk_read_time,     temp_blk_write_time,     wal_records,     wal_fpi,     wal_bytes,     jit_functions,     jit_generation_time,     jit_inlining_count,     jit_inlining_time,     jit_optimization_count,     jit_optimization_time,     jit_emission_count,     jit_emission_time,     jit_deform_count,     jit_deform_time,     stats_since,     minmax_stats_since    FROM pg_stat_statements(true) pg_stat_statements(userid, dbid, toplevel, queryid, query, plans, total_plan_time, min_plan_time, max_plan_time, mean_plan_time, stddev_plan_time, calls, total_exec_time, min_exec_time, max_exec_time, mean_exec_time, stddev_exec_time, rows, shared_blks_hit, shared_blks_read, shared_blks_dirtied, shared_blks_written, local_blks_hit, local_blks_read, local_blks_dirtied, local_blks_written, temp_blks_read, temp_blks_written, shared_blk_read_time, shared_blk_write_time, local_blk_read_time, local_blk_write_time, temp_blk_read_time, temp_blk_write_time, wal_records, wal_fpi, wal_bytes, jit_functions, jit_generation_time, jit_inlining_count, jit_inlining_time, jit_optimization_count, jit_optimization_time, jit_emission_count, jit_emission_time, jit_deform_count, jit_deform_time, stats_since, minmax_stats_since);"
      },
      {
        "schema": "extensions",
        "name": "pg_stat_statements_info",
        "definition": " SELECT dealloc,     stats_reset    FROM pg_stat_statements_info() pg_stat_statements_info(dealloc, stats_reset);"
      },
      {
        "schema": "vault",
        "name": "decrypted_secrets",
        "definition": " SELECT id,     name,     description,     secret,     convert_from(vault._crypto_aead_det_decrypt(message => decode(secret, 'base64'::text), additional => convert_to(id::text, 'utf8'::name), key_id => 0::bigint, context => '\\x7067736f6469756d'::bytea, nonce => nonce), 'utf8'::name) AS decrypted_secret,     key_id,     nonce,     created_at,     updated_at    FROM vault.secrets s;"
      }
    ],
    "functions": [
      {
        "schema": "auth",
        "name": "email",
        "signature": "email()",
        "return_type": "text",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION auth.email()  RETURNS text  LANGUAGE sql  STABLE AS $function$   select    coalesce(     nullif(current_setting('request.jwt.claim.email', true), ''),     (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')   )::text $function$ "
      },
      {
        "schema": "auth",
        "name": "jwt",
        "signature": "jwt()",
        "return_type": "jsonb",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION auth.jwt()  RETURNS jsonb  LANGUAGE sql  STABLE AS $function$   select      coalesce(         nullif(current_setting('request.jwt.claim', true), ''),         nullif(current_setting('request.jwt.claims', true), '')     )::jsonb $function$ "
      },
      {
        "schema": "auth",
        "name": "role",
        "signature": "role()",
        "return_type": "text",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION auth.role()  RETURNS text  LANGUAGE sql  STABLE AS $function$   select    coalesce(     nullif(current_setting('request.jwt.claim.role', true), ''),     (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')   )::text $function$ "
      },
      {
        "schema": "auth",
        "name": "uid",
        "signature": "uid()",
        "return_type": "uuid",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION auth.uid()  RETURNS uuid  LANGUAGE sql  STABLE AS $function$   select    coalesce(     nullif(current_setting('request.jwt.claim.sub', true), ''),     (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')   )::uuid $function$ "
      },
      {
        "schema": "extensions",
        "name": "armor",
        "signature": "armor(bytea)",
        "return_type": "text",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.armor(bytea)  RETURNS text  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pg_armor$function$ "
      },
      {
        "schema": "extensions",
        "name": "armor",
        "signature": "armor(bytea, text[], text[])",
        "return_type": "text",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.armor(bytea, text[], text[])  RETURNS text  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pg_armor$function$ "
      },
      {
        "schema": "extensions",
        "name": "crypt",
        "signature": "crypt(text, text)",
        "return_type": "text",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.crypt(text, text)  RETURNS text  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pg_crypt$function$ "
      },
      {
        "schema": "extensions",
        "name": "dearmor",
        "signature": "dearmor(text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.dearmor(text)  RETURNS bytea  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pg_dearmor$function$ "
      },
      {
        "schema": "extensions",
        "name": "decrypt",
        "signature": "decrypt(bytea, bytea, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.decrypt(bytea, bytea, text)  RETURNS bytea  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pg_decrypt$function$ "
      },
      {
        "schema": "extensions",
        "name": "decrypt_iv",
        "signature": "decrypt_iv(bytea, bytea, bytea, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text)  RETURNS bytea  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pg_decrypt_iv$function$ "
      },
      {
        "schema": "extensions",
        "name": "digest",
        "signature": "digest(bytea, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.digest(bytea, text)  RETURNS bytea  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pg_digest$function$ "
      },
      {
        "schema": "extensions",
        "name": "digest",
        "signature": "digest(text, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.digest(text, text)  RETURNS bytea  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pg_digest$function$ "
      },
      {
        "schema": "extensions",
        "name": "encrypt",
        "signature": "encrypt(bytea, bytea, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.encrypt(bytea, bytea, text)  RETURNS bytea  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pg_encrypt$function$ "
      },
      {
        "schema": "extensions",
        "name": "encrypt_iv",
        "signature": "encrypt_iv(bytea, bytea, bytea, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text)  RETURNS bytea  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pg_encrypt_iv$function$ "
      },
      {
        "schema": "extensions",
        "name": "gen_random_bytes",
        "signature": "gen_random_bytes(integer)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.gen_random_bytes(integer)  RETURNS bytea  LANGUAGE c  PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pg_random_bytes$function$ "
      },
      {
        "schema": "extensions",
        "name": "gen_random_uuid",
        "signature": "gen_random_uuid()",
        "return_type": "uuid",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.gen_random_uuid()  RETURNS uuid  LANGUAGE c  PARALLEL SAFE AS '$libdir/pgcrypto', $function$pg_random_uuid$function$ "
      },
      {
        "schema": "extensions",
        "name": "gen_salt",
        "signature": "gen_salt(text)",
        "return_type": "text",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text)  RETURNS text  LANGUAGE c  PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pg_gen_salt$function$ "
      },
      {
        "schema": "extensions",
        "name": "gen_salt",
        "signature": "gen_salt(text, integer)",
        "return_type": "text",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text, integer)  RETURNS text  LANGUAGE c  PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pg_gen_salt_rounds$function$ "
      },
      {
        "schema": "extensions",
        "name": "grant_pg_cron_access",
        "signature": "grant_pg_cron_access()",
        "return_type": "event_trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access()  RETURNS event_trigger  LANGUAGE plpgsql AS $function$ BEGIN   IF EXISTS (     SELECT     FROM pg_event_trigger_ddl_commands() AS ev     JOIN pg_extension AS ext     ON ev.objid = ext.oid     WHERE ext.extname = 'pg_cron'   )   THEN     grant usage on schema cron to postgres with grant option;     alter default privileges in schema cron grant all on tables to postgres with grant option;     alter default privileges in schema cron grant all on functions to postgres with grant option;     alter default privileges in schema cron grant all on sequences to postgres with grant option;     alter default privileges for user supabase_admin in schema cron grant all         on sequences to postgres with grant option;     alter default privileges for user supabase_admin in schema cron grant all         on tables to postgres with grant option;     alter default privileges for user supabase_admin in schema cron grant all         on functions to postgres with grant option;     grant all privileges on all tables in schema cron to postgres with grant option;     revoke all on table cron.job from postgres;     grant select on table cron.job to postgres with grant option;   END IF; END; $function$ "
      },
      {
        "schema": "extensions",
        "name": "grant_pg_graphql_access",
        "signature": "grant_pg_graphql_access()",
        "return_type": "event_trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION extensions.grant_pg_graphql_access()  RETURNS event_trigger  LANGUAGE plpgsql AS $function$ DECLARE     func_is_graphql_resolve bool; BEGIN     func_is_graphql_resolve = (         SELECT n.proname = 'resolve'         FROM pg_event_trigger_ddl_commands() AS ev         LEFT JOIN pg_catalog.pg_proc AS n         ON ev.objid = n.oid     );     IF func_is_graphql_resolve     THEN         -- Update public wrapper to pass all arguments through to the pg_graphql resolve func         DROP FUNCTION IF EXISTS graphql_public.graphql;         create or replace function graphql_public.graphql(             \"operationName\" text default null,             query text default null,             variables jsonb default null,             extensions jsonb default null         )             returns jsonb             language sql         as $$             select graphql.resolve(                 query := query,                 variables := coalesce(variables, '{}'),                 \"operationName\" := \"operationName\",                 extensions := extensions             );         $$;         -- This hook executes when `graphql.resolve` is created. That is not necessarily the last         -- function in the extension so we need to grant permissions on existing entities AND         -- update default permissions to any others that are created after `graphql.resolve`         grant usage on schema graphql to postgres, anon, authenticated, service_role;         grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;         grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;         grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;         alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;         alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;         alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;         -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles         grant usage on schema graphql_public to postgres with grant option;         grant usage on schema graphql to postgres with grant option;     END IF; END; $function$ "
      },
      {
        "schema": "extensions",
        "name": "grant_pg_net_access",
        "signature": "grant_pg_net_access()",
        "return_type": "event_trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()  RETURNS event_trigger  LANGUAGE plpgsql AS $function$ BEGIN   IF EXISTS (     SELECT 1     FROM pg_event_trigger_ddl_commands() AS ev     JOIN pg_extension AS ext     ON ev.objid = ext.oid     WHERE ext.extname = 'pg_net'   )   THEN     IF NOT EXISTS (       SELECT 1       FROM pg_roles       WHERE rolname = 'supabase_functions_admin'     )     THEN       CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;     END IF;     GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;     IF EXISTS (       SELECT FROM pg_extension       WHERE extname = 'pg_net'       -- all versions in use on existing projects as of 2025-02-20       -- version 0.12.0 onwards don't need these applied       AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')     ) THEN       ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;       ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;       ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;       ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;       REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;       REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;       GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;       GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;     END IF;   END IF; END; $function$ "
      },
      {
        "schema": "extensions",
        "name": "hmac",
        "signature": "hmac(bytea, bytea, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.hmac(bytea, bytea, text)  RETURNS bytea  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pg_hmac$function$ "
      },
      {
        "schema": "extensions",
        "name": "hmac",
        "signature": "hmac(text, text, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.hmac(text, text, text)  RETURNS bytea  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pg_hmac$function$ "
      },
      {
        "schema": "extensions",
        "name": "pg_stat_statements",
        "signature": "pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone)",
        "return_type": "SETOF record",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone)  RETURNS SETOF record  LANGUAGE c  PARALLEL SAFE STRICT AS '$libdir/pg_stat_statements', $function$pg_stat_statements_1_11$function$ "
      },
      {
        "schema": "extensions",
        "name": "pg_stat_statements_info",
        "signature": "pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone)",
        "return_type": "record",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone)  RETURNS record  LANGUAGE c  PARALLEL SAFE STRICT AS '$libdir/pg_stat_statements', $function$pg_stat_statements_info$function$ "
      },
      {
        "schema": "extensions",
        "name": "pg_stat_statements_reset",
        "signature": "pg_stat_statements_reset(userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0, minmax_only boolean DEFAULT false)",
        "return_type": "timestamp with time zone",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_reset(userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0, minmax_only boolean DEFAULT false)  RETURNS timestamp with time zone  LANGUAGE c  PARALLEL SAFE STRICT AS '$libdir/pg_stat_statements', $function$pg_stat_statements_reset_1_11$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_armor_headers",
        "signature": "pgp_armor_headers(text, OUT key text, OUT value text)",
        "return_type": "SETOF record",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text)  RETURNS SETOF record  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_armor_headers$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_key_id",
        "signature": "pgp_key_id(bytea)",
        "return_type": "text",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_key_id(bytea)  RETURNS text  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_key_id_w$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_pub_decrypt",
        "signature": "pgp_pub_decrypt(bytea, bytea)",
        "return_type": "text",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea)  RETURNS text  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_pub_decrypt",
        "signature": "pgp_pub_decrypt(bytea, bytea, text)",
        "return_type": "text",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text)  RETURNS text  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_pub_decrypt",
        "signature": "pgp_pub_decrypt(bytea, bytea, text, text)",
        "return_type": "text",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text)  RETURNS text  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_pub_decrypt_bytea",
        "signature": "pgp_pub_decrypt_bytea(bytea, bytea)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea)  RETURNS bytea  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_pub_decrypt_bytea",
        "signature": "pgp_pub_decrypt_bytea(bytea, bytea, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text)  RETURNS bytea  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_pub_decrypt_bytea",
        "signature": "pgp_pub_decrypt_bytea(bytea, bytea, text, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text)  RETURNS bytea  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_pub_encrypt",
        "signature": "pgp_pub_encrypt(text, bytea)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea)  RETURNS bytea  LANGUAGE c  PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_pub_encrypt",
        "signature": "pgp_pub_encrypt(text, bytea, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea, text)  RETURNS bytea  LANGUAGE c  PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_pub_encrypt_bytea",
        "signature": "pgp_pub_encrypt_bytea(bytea, bytea)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea)  RETURNS bytea  LANGUAGE c  PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_pub_encrypt_bytea",
        "signature": "pgp_pub_encrypt_bytea(bytea, bytea, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text)  RETURNS bytea  LANGUAGE c  PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_sym_decrypt",
        "signature": "pgp_sym_decrypt(bytea, text)",
        "return_type": "text",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text)  RETURNS text  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_sym_decrypt",
        "signature": "pgp_sym_decrypt(bytea, text, text)",
        "return_type": "text",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text, text)  RETURNS text  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_sym_decrypt_bytea",
        "signature": "pgp_sym_decrypt_bytea(bytea, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text)  RETURNS bytea  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_sym_decrypt_bytea",
        "signature": "pgp_sym_decrypt_bytea(bytea, text, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text)  RETURNS bytea  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_sym_encrypt",
        "signature": "pgp_sym_encrypt(text, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text)  RETURNS bytea  LANGUAGE c  PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_sym_encrypt",
        "signature": "pgp_sym_encrypt(text, text, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text, text)  RETURNS bytea  LANGUAGE c  PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_sym_encrypt_bytea",
        "signature": "pgp_sym_encrypt_bytea(bytea, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text)  RETURNS bytea  LANGUAGE c  PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgp_sym_encrypt_bytea",
        "signature": "pgp_sym_encrypt_bytea(bytea, text, text)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text)  RETURNS bytea  LANGUAGE c  PARALLEL SAFE STRICT AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$ "
      },
      {
        "schema": "extensions",
        "name": "pgrst_ddl_watch",
        "signature": "pgrst_ddl_watch()",
        "return_type": "event_trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch()  RETURNS event_trigger  LANGUAGE plpgsql AS $function$ DECLARE   cmd record; BEGIN   FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()   LOOP     IF cmd.command_tag IN (       'CREATE SCHEMA', 'ALTER SCHEMA'     , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'     , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'     , 'CREATE VIEW', 'ALTER VIEW'     , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'     , 'CREATE FUNCTION', 'ALTER FUNCTION'     , 'CREATE TRIGGER'     , 'CREATE TYPE', 'ALTER TYPE'     , 'CREATE RULE'     , 'COMMENT'     )     -- don't notify in case of CREATE TEMP table or other objects created on pg_temp     AND cmd.schema_name is distinct from 'pg_temp'     THEN       NOTIFY pgrst, 'reload schema';     END IF;   END LOOP; END; $function$ "
      },
      {
        "schema": "extensions",
        "name": "pgrst_drop_watch",
        "signature": "pgrst_drop_watch()",
        "return_type": "event_trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch()  RETURNS event_trigger  LANGUAGE plpgsql AS $function$ DECLARE   obj record; BEGIN   FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()   LOOP     IF obj.object_type IN (       'schema'     , 'table'     , 'foreign table'     , 'view'     , 'materialized view'     , 'function'     , 'trigger'     , 'type'     , 'rule'     )     AND obj.is_temporary IS false -- no pg_temp objects     THEN       NOTIFY pgrst, 'reload schema';     END IF;   END LOOP; END; $function$ "
      },
      {
        "schema": "extensions",
        "name": "set_graphql_placeholder",
        "signature": "set_graphql_placeholder()",
        "return_type": "event_trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()  RETURNS event_trigger  LANGUAGE plpgsql AS $function$     DECLARE     graphql_is_dropped bool;     BEGIN     graphql_is_dropped = (         SELECT ev.schema_name = 'graphql_public'         FROM pg_event_trigger_dropped_objects() AS ev         WHERE ev.schema_name = 'graphql_public'     );     IF graphql_is_dropped     THEN         create or replace function graphql_public.graphql(             \"operationName\" text default null,             query text default null,             variables jsonb default null,             extensions jsonb default null         )             returns jsonb             language plpgsql         as $$             DECLARE                 server_version float;             BEGIN                 server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);                 IF server_version >= 14 THEN                     RETURN jsonb_build_object(                         'errors', jsonb_build_array(                             jsonb_build_object(                                 'message', 'pg_graphql extension is not enabled.'                             )                         )                     );                 ELSE                     RETURN jsonb_build_object(                         'errors', jsonb_build_array(                             jsonb_build_object(                                 'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'                             )                         )                     );                 END IF;             END;         $$;     END IF;     END; $function$ "
      },
      {
        "schema": "extensions",
        "name": "uuid_generate_v1",
        "signature": "uuid_generate_v1()",
        "return_type": "uuid",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1()  RETURNS uuid  LANGUAGE c  PARALLEL SAFE STRICT AS '$libdir/uuid-ossp', $function$uuid_generate_v1$function$ "
      },
      {
        "schema": "extensions",
        "name": "uuid_generate_v1mc",
        "signature": "uuid_generate_v1mc()",
        "return_type": "uuid",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1mc()  RETURNS uuid  LANGUAGE c  PARALLEL SAFE STRICT AS '$libdir/uuid-ossp', $function$uuid_generate_v1mc$function$ "
      },
      {
        "schema": "extensions",
        "name": "uuid_generate_v3",
        "signature": "uuid_generate_v3(namespace uuid, name text)",
        "return_type": "uuid",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v3(namespace uuid, name text)  RETURNS uuid  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/uuid-ossp', $function$uuid_generate_v3$function$ "
      },
      {
        "schema": "extensions",
        "name": "uuid_generate_v4",
        "signature": "uuid_generate_v4()",
        "return_type": "uuid",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v4()  RETURNS uuid  LANGUAGE c  PARALLEL SAFE STRICT AS '$libdir/uuid-ossp', $function$uuid_generate_v4$function$ "
      },
      {
        "schema": "extensions",
        "name": "uuid_generate_v5",
        "signature": "uuid_generate_v5(namespace uuid, name text)",
        "return_type": "uuid",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v5(namespace uuid, name text)  RETURNS uuid  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/uuid-ossp', $function$uuid_generate_v5$function$ "
      },
      {
        "schema": "extensions",
        "name": "uuid_nil",
        "signature": "uuid_nil()",
        "return_type": "uuid",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_nil()  RETURNS uuid  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/uuid-ossp', $function$uuid_nil$function$ "
      },
      {
        "schema": "extensions",
        "name": "uuid_ns_dns",
        "signature": "uuid_ns_dns()",
        "return_type": "uuid",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_dns()  RETURNS uuid  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/uuid-ossp', $function$uuid_ns_dns$function$ "
      },
      {
        "schema": "extensions",
        "name": "uuid_ns_oid",
        "signature": "uuid_ns_oid()",
        "return_type": "uuid",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_oid()  RETURNS uuid  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/uuid-ossp', $function$uuid_ns_oid$function$ "
      },
      {
        "schema": "extensions",
        "name": "uuid_ns_url",
        "signature": "uuid_ns_url()",
        "return_type": "uuid",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_url()  RETURNS uuid  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/uuid-ossp', $function$uuid_ns_url$function$ "
      },
      {
        "schema": "extensions",
        "name": "uuid_ns_x500",
        "signature": "uuid_ns_x500()",
        "return_type": "uuid",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_x500()  RETURNS uuid  LANGUAGE c  IMMUTABLE PARALLEL SAFE STRICT AS '$libdir/uuid-ossp', $function$uuid_ns_x500$function$ "
      },
      {
        "schema": "graphql",
        "name": "_internal_resolve",
        "signature": "_internal_resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)",
        "return_type": "jsonb",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION graphql._internal_resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)  RETURNS jsonb  LANGUAGE c AS '$libdir/pg_graphql', $function$resolve_wrapper$function$ "
      },
      {
        "schema": "graphql",
        "name": "comment_directive",
        "signature": "comment_directive(comment_ text)",
        "return_type": "jsonb",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION graphql.comment_directive(comment_ text)  RETURNS jsonb  LANGUAGE sql  IMMUTABLE AS $function$     /*     comment on column public.account.name is '@graphql.name: myField'     */     select         coalesce(             (                 regexp_match(                     comment_,                     '@graphql\\((.+)\\)'                 )             )[1]::jsonb,             jsonb_build_object()         ) $function$ "
      },
      {
        "schema": "graphql",
        "name": "exception",
        "signature": "exception(message text)",
        "return_type": "text",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION graphql.exception(message text)  RETURNS text  LANGUAGE plpgsql AS $function$ begin     raise exception using errcode='22000', message=message; end; $function$ "
      },
      {
        "schema": "graphql",
        "name": "get_schema_version",
        "signature": "get_schema_version()",
        "return_type": "integer",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION graphql.get_schema_version()  RETURNS integer  LANGUAGE sql  SECURITY DEFINER AS $function$     select last_value from graphql.seq_schema_version; $function$ "
      },
      {
        "schema": "graphql",
        "name": "increment_schema_version",
        "signature": "increment_schema_version()",
        "return_type": "event_trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION graphql.increment_schema_version()  RETURNS event_trigger  LANGUAGE plpgsql  SECURITY DEFINER AS $function$ begin     perform pg_catalog.nextval('graphql.seq_schema_version'); end; $function$ "
      },
      {
        "schema": "graphql",
        "name": "resolve",
        "signature": "resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)",
        "return_type": "jsonb",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION graphql.resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)  RETURNS jsonb  LANGUAGE plpgsql AS $function$ declare     res jsonb;     message_text text; begin   begin     select graphql._internal_resolve(\"query\" := \"query\",                                      \"variables\" := \"variables\",                                      \"operationName\" := \"operationName\",                                      \"extensions\" := \"extensions\") into res;     return res;   exception     when others then     get stacked diagnostics message_text = message_text;     return     jsonb_build_object('data', null,                        'errors', jsonb_build_array(jsonb_build_object('message', message_text)));   end; end; $function$ "
      },
      {
        "schema": "graphql_public",
        "name": "graphql",
        "signature": "graphql(\"operationName\" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb)",
        "return_type": "jsonb",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION graphql_public.graphql(\"operationName\" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb)  RETURNS jsonb  LANGUAGE sql AS $function$             select graphql.resolve(                 query := query,                 variables := coalesce(variables, '{}'),                 \"operationName\" := \"operationName\",                 extensions := extensions             );         $function$ "
      },
      {
        "schema": "public",
        "name": "company_is_active",
        "signature": "company_is_active(code text)",
        "return_type": "boolean",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION public.company_is_active(code text)  RETURNS boolean  LANGUAGE sql  STABLE AS $function$   select     case       when code is null then false       when code = 'PLATFORM' then true       else exists (         select 1         from public.companies c         where c.\"companyCode\" = code           and c.\"isDisabled\" = false       )     end $function$ "
      },
      {
        "schema": "public",
        "name": "consume_platform_admin_reset_token",
        "signature": "consume_platform_admin_reset_token(plaintext_token text)",
        "return_type": "jsonb",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION public.consume_platform_admin_reset_token(plaintext_token text)  RETURNS jsonb  LANGUAGE plpgsql  SECURITY DEFINER  SET search_path TO 'public', 'auth', 'extensions', 'pg_catalog' AS $function$ declare   v_row record;   v_jwt_secret text;   v_now timestamptz := now();   v_exp int;   v_access_token text;   v_header jsonb;   v_payload jsonb;   v_header_b64 text;   v_payload_b64 text;   v_signing_input text;   v_sig bytea;   v_sig_b64 text; begin   if plaintext_token is null or length(trim(plaintext_token)) < 32 then     raise exception 'invalid token' using errcode = '22023';   end if;   -- Find and lock a valid (unused + unexpired) token row.   select t.id, t.user_id   into v_row   from public.platform_admin_reset_tokens t   join public.users u on u.id = t.user_id   where t.used_at is null     and t.expires_at > v_now     and u.role = 'platform_admin'     and u.company_code = 'PLATFORM'     and u.active = true     and t.token_hash = crypt(plaintext_token, t.token_hash)   for update;   if not found then     raise exception 'invalid token' using errcode = '22023';   end if;   update public.platform_admin_reset_tokens   set used_at = v_now   where id = v_row.id     and used_at is null;   if not found then     raise exception 'invalid token' using errcode = '22023';   end if;   update public.users   set force_pin_change = true   where id = v_row.user_id;   v_jwt_secret := current_setting('app.settings.jwt_secret', true);   if v_jwt_secret is null or v_jwt_secret = '' then     -- Fail closed: do not allow recovery without a signing secret.     raise exception 'recovery unavailable' using errcode = '0A000';   end if;   -- Short-lived JWT (10 minutes) scoped to a minimal DB role.   v_exp := floor(extract(epoch from (v_now + interval '10 minutes')))::int;   -- Mint a minimal HS256 JWT for PostgREST:   -- - role=anon (no direct table access)   -- - recovery=true claim gates the recovery-only PIN setter RPC   v_header := '{\"alg\":\"HS256\",\"typ\":\"JWT\"}'::jsonb;   v_payload := jsonb_build_object(     'aud', 'authenticated',     'role', 'anon',     'sub', v_row.user_id::text,     'iat', floor(extract(epoch from v_now))::int,     'exp', v_exp,     'recovery', true   );   v_header_b64 := regexp_replace(     translate(encode(convert_to(v_header::text, 'utf8'), 'base64'), '+/', '-_'),     '=',     '',     'g'   );   v_payload_b64 := regexp_replace(     translate(encode(convert_to(v_payload::text, 'utf8'), 'base64'), '+/', '-_'),     '=',     '',     'g'   );   v_signing_input := v_header_b64 || '.' || v_payload_b64;   v_sig := hmac(convert_to(v_signing_input, 'utf8'), convert_to(v_jwt_secret, 'utf8'), 'sha256');   v_sig_b64 := regexp_replace(translate(encode(v_sig, 'base64'), '+/', '-_'), '=', '', 'g');   v_access_token := v_signing_input || '.' || v_sig_b64;   return jsonb_build_object(     'token_type', 'bearer',     'access_token', v_access_token,     'expires_in', 600,     'user_id', v_row.user_id   ); end; $function$ "
      },
      {
        "schema": "public",
        "name": "create_platform_admin_reset_token",
        "signature": "create_platform_admin_reset_token(target_user_id uuid)",
        "return_type": "text",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION public.create_platform_admin_reset_token(target_user_id uuid)  RETURNS text  LANGUAGE plpgsql  SECURITY DEFINER  SET search_path TO 'public', 'auth', 'extensions', 'pg_catalog' AS $function$ declare   v_token text;   v_token_hash text;   v_secret text; begin   if auth.role() is distinct from 'service_role' then     raise exception 'forbidden' using errcode = '42501';   end if;   if target_user_id is null then     raise exception 'invalid target' using errcode = '22023';   end if;   perform 1   from public.users u   where u.id = target_user_id     and u.role = 'platform_admin'     and u.company_code = 'PLATFORM'     and u.active = true;   if not found then     raise exception 'target user not eligible' using errcode = '22023';   end if;   -- \u226532 bytes of entropy, safe for copy/paste (hex).   v_token := encode(gen_random_bytes(32), 'hex');   v_token_hash := crypt(v_token, gen_salt('bf', 12));   insert into public.platform_admin_reset_tokens (     user_id,     token_hash,     expires_at,     used_at,     created_by   )   values (     target_user_id,     v_token_hash,     now() + interval '15 minutes',     null,     coalesce(auth.uid()::text, current_setting('request.jwt.claim.sub', true), auth.role())   );   return v_token; end; $function$ "
      },
      {
        "schema": "public",
        "name": "current_company_code",
        "signature": "current_company_code()",
        "return_type": "text",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION public.current_company_code()  RETURNS text  LANGUAGE sql  STABLE SECURITY DEFINER  SET search_path TO 'public', 'auth' AS $function$   select u.company_code   from public.users u   where u.id = auth.uid() $function$ "
      },
      {
        "schema": "public",
        "name": "current_company_is_active",
        "signature": "current_company_is_active()",
        "return_type": "boolean",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION public.current_company_is_active()  RETURNS boolean  LANGUAGE sql  STABLE AS $function$   select public.company_is_active(public.current_company_code()) $function$ "
      },
      {
        "schema": "public",
        "name": "current_employee_id",
        "signature": "current_employee_id()",
        "return_type": "uuid",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION public.current_employee_id()  RETURNS uuid  LANGUAGE sql  STABLE SECURITY DEFINER  SET search_path TO 'public', 'auth' AS $function$   select u.\"employeeId\"   from public.users u   where u.id = auth.uid() $function$ "
      },
      {
        "schema": "public",
        "name": "current_role",
        "signature": "current_role()",
        "return_type": "user_role",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION public.\"current_role\"()  RETURNS user_role  LANGUAGE sql  STABLE AS $function$   select u.role   from public.users u   where u.id = auth.uid() $function$ "
      },
      {
        "schema": "public",
        "name": "current_user_active",
        "signature": "current_user_active()",
        "return_type": "boolean",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION public.current_user_active()  RETURNS boolean  LANGUAGE sql  STABLE AS $function$   select coalesce(u.active, false)   from public.users u   where u.id = auth.uid() $function$ "
      },
      {
        "schema": "public",
        "name": "current_user_role",
        "signature": "current_user_role()",
        "return_type": "user_role",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION public.current_user_role()  RETURNS user_role  LANGUAGE sql  STABLE SECURITY DEFINER  SET search_path TO 'public', 'auth' AS $function$   select u.role   from public.users u   where u.id = auth.uid() $function$ "
      },
      {
        "schema": "public",
        "name": "is_manager",
        "signature": "is_manager()",
        "return_type": "boolean",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION public.is_manager()  RETURNS boolean  LANGUAGE sql  STABLE SECURITY DEFINER  SET search_path TO 'public', 'auth' AS $function$   select public.current_user_role() = 'manager' $function$ "
      },
      {
        "schema": "public",
        "name": "is_platform_admin",
        "signature": "is_platform_admin()",
        "return_type": "boolean",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION public.is_platform_admin()  RETURNS boolean  LANGUAGE sql  STABLE SECURITY DEFINER  SET search_path TO 'public', 'auth' AS $function$   select public.current_user_role() = 'platform_admin' $function$ "
      },
      {
        "schema": "public",
        "name": "platform_admin_recovery_set_pin",
        "signature": "platform_admin_recovery_set_pin(new_pin text)",
        "return_type": "jsonb",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION public.platform_admin_recovery_set_pin(new_pin text)  RETURNS jsonb  LANGUAGE plpgsql  SECURITY DEFINER  SET search_path TO 'public', 'auth', 'extensions', 'pg_catalog' AS $function$ declare   v_user_id uuid;   v_company_code text;   v_username text;   v_pin_hash text; begin   if auth.role() is distinct from 'anon' then     raise exception 'forbidden' using errcode = '42501';   end if;   v_user_id := auth.uid();   if v_user_id is null then     raise exception 'forbidden' using errcode = '42501';   end if;   if current_setting('request.jwt.claim.recovery', true) is distinct from 'true' then     raise exception 'forbidden' using errcode = '42501';   end if;   if new_pin is null or new_pin !~ '^[0-9]{4}$' then     raise exception 'invalid pin' using errcode = '22023';   end if;   select u.company_code, u.username   into v_company_code, v_username   from public.users u   where u.id = v_user_id     and u.role = 'platform_admin'     and u.company_code = 'PLATFORM'     and u.active = true     and u.force_pin_change = true;   if not found then     raise exception 'forbidden' using errcode = '42501';   end if;   -- Update Supabase Auth password (bcrypt).   update auth.users   set encrypted_password = crypt(new_pin, gen_salt('bf', 12)),       updated_at = now()   where id = v_user_id;   if not found then     raise exception 'forbidden' using errcode = '42501';   end if;   -- Keep app-level pinHash in sync with the auth password.   v_pin_hash := encode(     digest(convert_to(v_company_code || ':' || v_username || ':' || new_pin, 'utf8'), 'sha256'),     'hex'   );   update public.users   set \"pinHash\" = v_pin_hash,       force_pin_change = false   where id = v_user_id;   return jsonb_build_object('ok', true); end; $function$ "
      },
      {
        "schema": "public",
        "name": "prevent_company_code_update",
        "signature": "prevent_company_code_update()",
        "return_type": "trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION public.prevent_company_code_update()  RETURNS trigger  LANGUAGE plpgsql AS $function$ begin   if new.\"companyCode\" is distinct from old.\"companyCode\" then     raise exception 'companyCode is immutable';   end if;   return new; end $function$ "
      },
      {
        "schema": "public",
        "name": "set_updated_at",
        "signature": "set_updated_at()",
        "return_type": "trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION public.set_updated_at()  RETURNS trigger  LANGUAGE plpgsql AS $function$ begin   new.\"updatedAt\" = now();   return new; end $function$ "
      },
      {
        "schema": "public",
        "name": "sync_my_pin_hash_and_clear_force_pin_change",
        "signature": "sync_my_pin_hash_and_clear_force_pin_change(new_pin text)",
        "return_type": "jsonb",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION public.sync_my_pin_hash_and_clear_force_pin_change(new_pin text)  RETURNS jsonb  LANGUAGE plpgsql  SECURITY DEFINER  SET search_path TO 'public', 'auth', 'extensions', 'pg_catalog' AS $function$ declare   v_user_id uuid;   v_company_code text;   v_username text;   v_pin_hash text; begin   v_user_id := auth.uid();   if v_user_id is null then     raise exception 'forbidden' using errcode = '42501';   end if;   if new_pin is null or new_pin !~ '^[0-9]{4}$' then     raise exception 'invalid pin' using errcode = '22023';   end if;   -- Prevent bypassing `force_pin_change`: require the PIN to match auth.users.   perform 1   from auth.users au   where au.id = v_user_id     and au.encrypted_password = crypt(new_pin, au.encrypted_password);   if not found then     raise exception 'forbidden' using errcode = '42501';   end if;   select u.company_code, u.username   into v_company_code, v_username   from public.users u   where u.id = v_user_id     and u.active = true;   if not found then     raise exception 'forbidden' using errcode = '42501';   end if;   v_pin_hash := encode(     digest(convert_to(v_company_code || ':' || v_username || ':' || new_pin, 'utf8'), 'sha256'),     'hex'   );   update public.users   set \"pinHash\" = v_pin_hash,       force_pin_change = false   where id = v_user_id;   return jsonb_build_object('ok', true); end; $function$ "
      },
      {
        "schema": "realtime",
        "name": "apply_rls",
        "signature": "apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024))",
        "return_type": "SETOF realtime.wal_rls",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024))  RETURNS SETOF realtime.wal_rls  LANGUAGE plpgsql AS $function$ declare -- Regclass of the table e.g. public.notes entity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass; -- I, U, D, T: insert, update ... action realtime.action = (     case wal ->> 'action'         when 'I' then 'INSERT'         when 'U' then 'UPDATE'         when 'D' then 'DELETE'         else 'ERROR'     end ); -- Is row level security enabled for the table is_rls_enabled bool = relrowsecurity from pg_class where oid = entity_; subscriptions realtime.subscription[] = array_agg(subs)     from         realtime.subscription subs     where         subs.entity = entity_; -- Subscription vars roles regrole[] = array_agg(distinct us.claims_role::text)     from         unnest(subscriptions) us; working_role regrole; claimed_role regrole; claims jsonb; subscription_id uuid; subscription_has_access bool; visible_to_subscription_ids uuid[] = '{}'; -- structured info for wal's columns columns realtime.wal_column[]; -- previous identity values for update/delete old_columns realtime.wal_column[]; error_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes; -- Primary jsonb output for record output jsonb; begin perform set_config('role', null, true); columns =     array_agg(         (             x->>'name',             x->>'type',             x->>'typeoid',             realtime.cast(                 (x->'value') #>> '{}',                 coalesce(                     (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4                     (x->>'type')::regtype                 )             ),             (pks ->> 'name') is not null,             true         )::realtime.wal_column     )     from         jsonb_array_elements(wal -> 'columns') x         left join jsonb_array_elements(wal -> 'pk') pks             on (x ->> 'name') = (pks ->> 'name'); old_columns =     array_agg(         (             x->>'name',             x->>'type',             x->>'typeoid',             realtime.cast(                 (x->'value') #>> '{}',                 coalesce(                     (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4                     (x->>'type')::regtype                 )             ),             (pks ->> 'name') is not null,             true         )::realtime.wal_column     )     from         jsonb_array_elements(wal -> 'identity') x         left join jsonb_array_elements(wal -> 'pk') pks             on (x ->> 'name') = (pks ->> 'name'); for working_role in select * from unnest(roles) loop     -- Update `is_selectable` for columns and old_columns     columns =         array_agg(             (                 c.name,                 c.type_name,                 c.type_oid,                 c.value,                 c.is_pkey,                 pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')             )::realtime.wal_column         )         from             unnest(columns) c;     old_columns =             array_agg(                 (                     c.name,                     c.type_name,                     c.type_oid,                     c.value,                     c.is_pkey,                     pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')                 )::realtime.wal_column             )             from                 unnest(old_columns) c;     if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then         return next (             jsonb_build_object(                 'schema', wal ->> 'schema',                 'table', wal ->> 'table',                 'type', action             ),             is_rls_enabled,             -- subscriptions is already filtered by entity             (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),             array['Error 400: Bad Request, no primary key']         )::realtime.wal_rls;     -- The claims role does not have SELECT permission to the primary key of entity     elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then         return next (             jsonb_build_object(                 'schema', wal ->> 'schema',                 'table', wal ->> 'table',                 'type', action             ),             is_rls_enabled,             (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),             array['Error 401: Unauthorized']         )::realtime.wal_rls;     else         output = jsonb_build_object(             'schema', wal ->> 'schema',             'table', wal ->> 'table',             'type', action,             'commit_timestamp', to_char(                 ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),                 'YYYY-MM-DD\"T\"HH24:MI:SS.MS\"Z\"'             ),             'columns', (                 select                     jsonb_agg(                         jsonb_build_object(                             'name', pa.attname,                             'type', pt.typname                         )                         order by pa.attnum asc                     )                 from                     pg_attribute pa                     join pg_type pt                         on pa.atttypid = pt.oid                 where                     attrelid = entity_                     and attnum > 0                     and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')             )         )         -- Add \"record\" key for insert and update         || case             when action in ('INSERT', 'UPDATE') then                 jsonb_build_object(                     'record',                     (                         select                             jsonb_object_agg(                                 -- if unchanged toast, get column name and value from old record                                 coalesce((c).name, (oc).name),                                 case                                     when (c).name is null then (oc).value                                     else (c).value                                 end                             )                         from                             unnest(columns) c                             full outer join unnest(old_columns) oc                                 on (c).name = (oc).name                         where                             coalesce((c).is_selectable, (oc).is_selectable)                             and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))                     )                 )             else '{}'::jsonb         end         -- Add \"old_record\" key for update and delete         || case             when action = 'UPDATE' then                 jsonb_build_object(                         'old_record',                         (                             select jsonb_object_agg((c).name, (c).value)                             from unnest(old_columns) c                             where                                 (c).is_selectable                                 and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))                         )                     )             when action = 'DELETE' then                 jsonb_build_object(                     'old_record',                     (                         select jsonb_object_agg((c).name, (c).value)                         from unnest(old_columns) c                         where                             (c).is_selectable                             and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))                             and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey                     )                 )             else '{}'::jsonb         end;         -- Create the prepared statement         if is_rls_enabled and action <> 'DELETE' then             if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then                 deallocate walrus_rls_stmt;             end if;             execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);         end if;         visible_to_subscription_ids = '{}';         for subscription_id, claims in (                 select                     subs.subscription_id,                     subs.claims                 from                     unnest(subscriptions) subs                 where                     subs.entity = entity_                     and subs.claims_role = working_role                     and (                         realtime.is_visible_through_filters(columns, subs.filters)                         or (                           action = 'DELETE'                           and realtime.is_visible_through_filters(old_columns, subs.filters)                         )                     )         ) loop             if not is_rls_enabled or action = 'DELETE' then                 visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;             else                 -- Check if RLS allows the role to see the record                 perform                     -- Trim leading and trailing quotes from working_role because set_config                     -- doesn't recognize the role as valid if they are included                     set_config('role', trim(both '\"' from working_role::text), true),                     set_config('request.jwt.claims', claims::text, true);                 execute 'execute walrus_rls_stmt' into subscription_has_access;                 if subscription_has_access then                     visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;                 end if;             end if;         end loop;         perform set_config('role', null, true);         return next (             output,             is_rls_enabled,             visible_to_subscription_ids,             case                 when error_record_exceeds_max_size then array['Error 413: Payload Too Large']                 else '{}'             end         )::realtime.wal_rls;     end if; end loop; perform set_config('role', null, true); end; $function$ "
      },
      {
        "schema": "realtime",
        "name": "broadcast_changes",
        "signature": "broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text)",
        "return_type": "void",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text)  RETURNS void  LANGUAGE plpgsql AS $function$ DECLARE     -- Declare a variable to hold the JSONB representation of the row     row_data jsonb := '{}'::jsonb; BEGIN     IF level = 'STATEMENT' THEN         RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';     END IF;     -- Check the operation type and handle accordingly     IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN         row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);         PERFORM realtime.send (row_data, event_name, topic_name);     ELSE         RAISE EXCEPTION 'Unexpected operation type: %', operation;     END IF; EXCEPTION     WHEN OTHERS THEN         RAISE EXCEPTION 'Failed to process the row: %', SQLERRM; END; $function$ "
      },
      {
        "schema": "realtime",
        "name": "build_prepared_statement_sql",
        "signature": "build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[])",
        "return_type": "text",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[])  RETURNS text  LANGUAGE sql AS $function$       /*       Builds a sql string that, if executed, creates a prepared statement to       tests retrive a row from *entity* by its primary key columns.       Example           select realtime.build_prepared_statement_sql('public.notes', '{\"id\"}'::text[], '{\"bigint\"}'::text[])       */           select       'prepare ' || prepared_statement_name || ' as           select               exists(                   select                       1                   from                       ' || entity || '                   where                       ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '               )'           from               unnest(columns) pkc           where               pkc.is_pkey           group by               entity       $function$ "
      },
      {
        "schema": "realtime",
        "name": "cast",
        "signature": "cast(val text, type_ regtype)",
        "return_type": "jsonb",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION realtime.\"cast\"(val text, type_ regtype)  RETURNS jsonb  LANGUAGE plpgsql  IMMUTABLE AS $function$     declare       res jsonb;     begin       execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;       return res;     end     $function$ "
      },
      {
        "schema": "realtime",
        "name": "check_equality_op",
        "signature": "check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text)",
        "return_type": "boolean",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text)  RETURNS boolean  LANGUAGE plpgsql  IMMUTABLE AS $function$       /*       Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness       */       declare           op_symbol text = (               case                   when op = 'eq' then '='                   when op = 'neq' then '!='                   when op = 'lt' then '<'                   when op = 'lte' then '<='                   when op = 'gt' then '>'                   when op = 'gte' then '>='                   when op = 'in' then '= any'                   else 'UNKNOWN OP'               end           );           res boolean;       begin           execute format(               'select %L::'|| type_::text || ' ' || op_symbol               || ' ( %L::'               || (                   case                       when op = 'in' then type_::text || '[]'                       else type_::text end               )               || ')', val_1, val_2) into res;           return res;       end;       $function$ "
      },
      {
        "schema": "realtime",
        "name": "is_visible_through_filters",
        "signature": "is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])",
        "return_type": "boolean",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])  RETURNS boolean  LANGUAGE sql  IMMUTABLE AS $function$     /*     Should the record be visible (true) or filtered out (false) after *filters* are applied     */         select             -- Default to allowed when no filters present             $2 is null -- no filters. this should not happen because subscriptions has a default             or array_length($2, 1) is null -- array length of an empty array is null             or bool_and(                 coalesce(                     realtime.check_equality_op(                         op:=f.op,                         type_:=coalesce(                             col.type_oid::regtype, -- null when wal2json version <= 2.4                             col.type_name::regtype                         ),                         -- cast jsonb to text                         val_1:=col.value #>> '{}',                         val_2:=f.value                     ),                     false -- if null, filter does not match                 )             )         from             unnest(filters) f             join unnest(columns) col                 on f.column_name = col.name;     $function$ "
      },
      {
        "schema": "realtime",
        "name": "list_changes",
        "signature": "list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer)",
        "return_type": "SETOF realtime.wal_rls",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer)  RETURNS SETOF realtime.wal_rls  LANGUAGE sql  SET log_min_messages TO 'fatal' AS $function$       with pub as (         select           concat_ws(             ',',             case when bool_or(pubinsert) then 'insert' else null end,             case when bool_or(pubupdate) then 'update' else null end,             case when bool_or(pubdelete) then 'delete' else null end           ) as w2j_actions,           coalesce(             string_agg(               realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),               ','             ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),             ''           ) w2j_add_tables         from           pg_publication pp           left join pg_publication_tables ppt             on pp.pubname = ppt.pubname         where           pp.pubname = publication         group by           pp.pubname         limit 1       ),       w2j as (         select           x.*, pub.w2j_add_tables         from           pub,           pg_logical_slot_get_changes(             slot_name, null, max_changes,             'include-pk', 'true',             'include-transaction', 'false',             'include-timestamp', 'true',             'include-type-oids', 'true',             'format-version', '2',             'actions', pub.w2j_actions,             'add-tables', pub.w2j_add_tables           ) x       )       select         xyz.wal,         xyz.is_rls_enabled,         xyz.subscription_ids,         xyz.errors       from         w2j,         realtime.apply_rls(           wal := w2j.data::jsonb,           max_record_bytes := max_record_bytes         ) xyz(wal, is_rls_enabled, subscription_ids, errors)       where         w2j.w2j_add_tables <> ''         and xyz.subscription_ids[1] is not null     $function$ "
      },
      {
        "schema": "realtime",
        "name": "quote_wal2json",
        "signature": "quote_wal2json(entity regclass)",
        "return_type": "text",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION realtime.quote_wal2json(entity regclass)  RETURNS text  LANGUAGE sql  IMMUTABLE STRICT AS $function$       select         (           select string_agg('' || ch,'')           from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)           where             not (x.idx = 1 and x.ch = '\"')             and not (               x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)               and x.ch = '\"'             )         )         || '.'         || (           select string_agg('' || ch,'')           from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)           where             not (x.idx = 1 and x.ch = '\"')             and not (               x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)               and x.ch = '\"'             )           )       from         pg_class pc         join pg_namespace nsp           on pc.relnamespace = nsp.oid       where         pc.oid = entity     $function$ "
      },
      {
        "schema": "realtime",
        "name": "send",
        "signature": "send(payload jsonb, event text, topic text, private boolean DEFAULT true)",
        "return_type": "void",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true)  RETURNS void  LANGUAGE plpgsql AS $function$ DECLARE   generated_id uuid;   final_payload jsonb; BEGIN   BEGIN     -- Generate a new UUID for the id     generated_id := gen_random_uuid();     -- Check if payload has an 'id' key, if not, add the generated UUID     IF payload ? 'id' THEN       final_payload := payload;     ELSE       final_payload := jsonb_set(payload, '{id}', to_jsonb(generated_id));     END IF;     -- Set the topic configuration     EXECUTE format('SET LOCAL realtime.topic TO %L', topic);     -- Attempt to insert the message     INSERT INTO realtime.messages (id, payload, event, topic, private, extension)     VALUES (generated_id, final_payload, event, topic, private, 'broadcast');   EXCEPTION     WHEN OTHERS THEN       -- Capture and notify the error       RAISE WARNING 'ErrorSendingBroadcastMessage: %', SQLERRM;   END; END; $function$ "
      },
      {
        "schema": "realtime",
        "name": "subscription_check_filters",
        "signature": "subscription_check_filters()",
        "return_type": "trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION realtime.subscription_check_filters()  RETURNS trigger  LANGUAGE plpgsql AS $function$     /*     Validates that the user defined filters for a subscription:     - refer to valid columns that the claimed role may access     - values are coercable to the correct column type     */     declare         col_names text[] = coalesce(                 array_agg(c.column_name order by c.ordinal_position),                 '{}'::text[]             )             from                 information_schema.columns c             where                 format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity                 and pg_catalog.has_column_privilege(                     (new.claims ->> 'role'),                     format('%I.%I', c.table_schema, c.table_name)::regclass,                     c.column_name,                     'SELECT'                 );         filter realtime.user_defined_filter;         col_type regtype;         in_val jsonb;     begin         for filter in select * from unnest(new.filters) loop             -- Filtered column is valid             if not filter.column_name = any(col_names) then                 raise exception 'invalid column for filter %', filter.column_name;             end if;             -- Type is sanitized and safe for string interpolation             col_type = (                 select atttypid::regtype                 from pg_catalog.pg_attribute                 where attrelid = new.entity                       and attname = filter.column_name             );             if col_type is null then                 raise exception 'failed to lookup type for column %', filter.column_name;             end if;             -- Set maximum number of entries for in filter             if filter.op = 'in'::realtime.equality_op then                 in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);                 if coalesce(jsonb_array_length(in_val), 0) > 100 then                     raise exception 'too many values for `in` filter. Maximum 100';                 end if;             else                 -- raises an exception if value is not coercable to type                 perform realtime.cast(filter.value, col_type);             end if;         end loop;         -- Apply consistent order to filters so the unique constraint on         -- (subscription_id, entity, filters) can't be tricked by a different filter order         new.filters = coalesce(             array_agg(f order by f.column_name, f.op, f.value),             '{}'         ) from unnest(new.filters) f;         return new;     end;     $function$ "
      },
      {
        "schema": "realtime",
        "name": "to_regrole",
        "signature": "to_regrole(role_name text)",
        "return_type": "regrole",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION realtime.to_regrole(role_name text)  RETURNS regrole  LANGUAGE sql  IMMUTABLE AS $function$ select role_name::regrole $function$ "
      },
      {
        "schema": "realtime",
        "name": "topic",
        "signature": "topic()",
        "return_type": "text",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION realtime.topic()  RETURNS text  LANGUAGE sql  STABLE AS $function$ select nullif(current_setting('realtime.topic', true), '')::text; $function$ "
      },
      {
        "schema": "storage",
        "name": "add_prefixes",
        "signature": "add_prefixes(_bucket_id text, _name text)",
        "return_type": "void",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.add_prefixes(_bucket_id text, _name text)  RETURNS void  LANGUAGE plpgsql  SECURITY DEFINER AS $function$ DECLARE     prefixes text[]; BEGIN     prefixes := \"storage\".\"get_prefixes\"(\"_name\");     IF array_length(prefixes, 1) > 0 THEN         INSERT INTO storage.prefixes (name, bucket_id)         SELECT UNNEST(prefixes) as name, \"_bucket_id\" ON CONFLICT DO NOTHING;     END IF; END; $function$ "
      },
      {
        "schema": "storage",
        "name": "can_insert_object",
        "signature": "can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)",
        "return_type": "void",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)  RETURNS void  LANGUAGE plpgsql AS $function$ BEGIN   INSERT INTO \"storage\".\"objects\" (\"bucket_id\", \"name\", \"owner\", \"metadata\") VALUES (bucketid, name, owner, metadata);   -- hack to rollback the successful insert   RAISE sqlstate 'PT200' using   message = 'ROLLBACK',   detail = 'rollback successful insert'; END $function$ "
      },
      {
        "schema": "storage",
        "name": "delete_leaf_prefixes",
        "signature": "delete_leaf_prefixes(bucket_ids text[], names text[])",
        "return_type": "void",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.delete_leaf_prefixes(bucket_ids text[], names text[])  RETURNS void  LANGUAGE plpgsql  SECURITY DEFINER AS $function$ DECLARE     v_rows_deleted integer; BEGIN     LOOP         WITH candidates AS (             SELECT DISTINCT                 t.bucket_id,                 unnest(storage.get_prefixes(t.name)) AS name             FROM unnest(bucket_ids, names) AS t(bucket_id, name)         ),         uniq AS (              SELECT                  bucket_id,                  name,                  storage.get_level(name) AS level              FROM candidates              WHERE name <> ''              GROUP BY bucket_id, name         ),         leaf AS (              SELECT                  p.bucket_id,                  p.name,                  p.level              FROM storage.prefixes AS p                   JOIN uniq AS u                        ON u.bucket_id = p.bucket_id                            AND u.name = p.name                            AND u.level = p.level              WHERE NOT EXISTS (                  SELECT 1                  FROM storage.objects AS o                  WHERE o.bucket_id = p.bucket_id                    AND o.level = p.level + 1                    AND o.name COLLATE \"C\" LIKE p.name || '/%'              )              AND NOT EXISTS (                  SELECT 1                  FROM storage.prefixes AS c                  WHERE c.bucket_id = p.bucket_id                    AND c.level = p.level + 1                    AND c.name COLLATE \"C\" LIKE p.name || '/%'              )         )         DELETE         FROM storage.prefixes AS p             USING leaf AS l         WHERE p.bucket_id = l.bucket_id           AND p.name = l.name           AND p.level = l.level;         GET DIAGNOSTICS v_rows_deleted = ROW_COUNT;         EXIT WHEN v_rows_deleted = 0;     END LOOP; END; $function$ "
      },
      {
        "schema": "storage",
        "name": "delete_prefix",
        "signature": "delete_prefix(_bucket_id text, _name text)",
        "return_type": "boolean",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.delete_prefix(_bucket_id text, _name text)  RETURNS boolean  LANGUAGE plpgsql  SECURITY DEFINER AS $function$ BEGIN     -- Check if we can delete the prefix     IF EXISTS(         SELECT FROM \"storage\".\"prefixes\"         WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"           AND level = \"storage\".\"get_level\"(\"_name\") + 1           AND \"prefixes\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'         LIMIT 1     )     OR EXISTS(         SELECT FROM \"storage\".\"objects\"         WHERE \"objects\".\"bucket_id\" = \"_bucket_id\"           AND \"storage\".\"get_level\"(\"objects\".\"name\") = \"storage\".\"get_level\"(\"_name\") + 1           AND \"objects\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'         LIMIT 1     ) THEN     -- There are sub-objects, skip deletion     RETURN false;     ELSE         DELETE FROM \"storage\".\"prefixes\"         WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"           AND level = \"storage\".\"get_level\"(\"_name\")           AND \"prefixes\".\"name\" = \"_name\";         RETURN true;     END IF; END; $function$ "
      },
      {
        "schema": "storage",
        "name": "delete_prefix_hierarchy_trigger",
        "signature": "delete_prefix_hierarchy_trigger()",
        "return_type": "trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.delete_prefix_hierarchy_trigger()  RETURNS trigger  LANGUAGE plpgsql AS $function$ DECLARE     prefix text; BEGIN     prefix := \"storage\".\"get_prefix\"(OLD.\"name\");     IF coalesce(prefix, '') != '' THEN         PERFORM \"storage\".\"delete_prefix\"(OLD.\"bucket_id\", prefix);     END IF;     RETURN OLD; END; $function$ "
      },
      {
        "schema": "storage",
        "name": "enforce_bucket_name_length",
        "signature": "enforce_bucket_name_length()",
        "return_type": "trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.enforce_bucket_name_length()  RETURNS trigger  LANGUAGE plpgsql AS $function$ begin     if length(new.name) > 100 then         raise exception 'bucket name \"%\" is too long (% characters). Max is 100.', new.name, length(new.name);     end if;     return new; end; $function$ "
      },
      {
        "schema": "storage",
        "name": "extension",
        "signature": "extension(name text)",
        "return_type": "text",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.extension(name text)  RETURNS text  LANGUAGE plpgsql  IMMUTABLE AS $function$ DECLARE     _parts text[];     _filename text; BEGIN     SELECT string_to_array(name, '/') INTO _parts;     SELECT _parts[array_length(_parts,1)] INTO _filename;     RETURN reverse(split_part(reverse(_filename), '.', 1)); END $function$ "
      },
      {
        "schema": "storage",
        "name": "filename",
        "signature": "filename(name text)",
        "return_type": "text",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.filename(name text)  RETURNS text  LANGUAGE plpgsql AS $function$ DECLARE _parts text[]; BEGIN select string_to_array(name, '/') into _parts; return _parts[array_length(_parts,1)]; END $function$ "
      },
      {
        "schema": "storage",
        "name": "foldername",
        "signature": "foldername(name text)",
        "return_type": "text[]",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.foldername(name text)  RETURNS text[]  LANGUAGE plpgsql  IMMUTABLE AS $function$ DECLARE     _parts text[]; BEGIN     -- Split on \"/\" to get path segments     SELECT string_to_array(name, '/') INTO _parts;     -- Return everything except the last segment     RETURN _parts[1 : array_length(_parts,1) - 1]; END $function$ "
      },
      {
        "schema": "storage",
        "name": "get_level",
        "signature": "get_level(name text)",
        "return_type": "integer",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION storage.get_level(name text)  RETURNS integer  LANGUAGE sql  IMMUTABLE STRICT AS $function$ SELECT array_length(string_to_array(\"name\", '/'), 1); $function$ "
      },
      {
        "schema": "storage",
        "name": "get_prefix",
        "signature": "get_prefix(name text)",
        "return_type": "text",
        "language": "sql",
        "definition": "CREATE OR REPLACE FUNCTION storage.get_prefix(name text)  RETURNS text  LANGUAGE sql  IMMUTABLE STRICT AS $function$ SELECT     CASE WHEN strpos(\"name\", '/') > 0 THEN              regexp_replace(\"name\", '[\\/]{1}[^\\/]+\\/?$', '')          ELSE              ''         END; $function$ "
      },
      {
        "schema": "storage",
        "name": "get_prefixes",
        "signature": "get_prefixes(name text)",
        "return_type": "text[]",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.get_prefixes(name text)  RETURNS text[]  LANGUAGE plpgsql  IMMUTABLE STRICT AS $function$ DECLARE     parts text[];     prefixes text[];     prefix text; BEGIN     -- Split the name into parts by '/'     parts := string_to_array(\"name\", '/');     prefixes := '{}';     -- Construct the prefixes, stopping one level below the last part     FOR i IN 1..array_length(parts, 1) - 1 LOOP             prefix := array_to_string(parts[1:i], '/');             prefixes := array_append(prefixes, prefix);     END LOOP;     RETURN prefixes; END; $function$ "
      },
      {
        "schema": "storage",
        "name": "get_size_by_bucket",
        "signature": "get_size_by_bucket()",
        "return_type": "TABLE(size bigint, bucket_id text)",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()  RETURNS TABLE(size bigint, bucket_id text)  LANGUAGE plpgsql  STABLE AS $function$ BEGIN     return query         select sum((metadata->>'size')::bigint) as size, obj.bucket_id         from \"storage\".objects as obj         group by obj.bucket_id; END $function$ "
      },
      {
        "schema": "storage",
        "name": "list_multipart_uploads_with_delimiter",
        "signature": "list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)",
        "return_type": "TABLE(key text, id text, created_at timestamp with time zone)",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)  RETURNS TABLE(key text, id text, created_at timestamp with time zone)  LANGUAGE plpgsql AS $function$ BEGIN     RETURN QUERY EXECUTE         'SELECT DISTINCT ON(key COLLATE \"C\") * from (             SELECT                 CASE                     WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN                         substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))                     ELSE                         key                 END AS key, id, created_at             FROM                 storage.s3_multipart_uploads             WHERE                 bucket_id = $5 AND                 key ILIKE $1 || ''%'' AND                 CASE                     WHEN $4 != '''' AND $6 = '''' THEN                         CASE                             WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN                                 substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE \"C\" > $4                             ELSE                                 key COLLATE \"C\" > $4                             END                     ELSE                         true                 END AND                 CASE                     WHEN $6 != '''' THEN                         id COLLATE \"C\" > $6                     ELSE                         true                     END             ORDER BY                 key COLLATE \"C\" ASC, created_at ASC) as e order by key COLLATE \"C\" LIMIT $3'         USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token; END; $function$ "
      },
      {
        "schema": "storage",
        "name": "list_objects_with_delimiter",
        "signature": "list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)",
        "return_type": "TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)  RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)  LANGUAGE plpgsql AS $function$ BEGIN     RETURN QUERY EXECUTE         'SELECT DISTINCT ON(name COLLATE \"C\") * from (             SELECT                 CASE                     WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN                         substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))                     ELSE                         name                 END AS name, id, metadata, updated_at             FROM                 storage.objects             WHERE                 bucket_id = $5 AND                 name ILIKE $1 || ''%'' AND                 CASE                     WHEN $6 != '''' THEN                     name COLLATE \"C\" > $6                 ELSE true END                 AND CASE                     WHEN $4 != '''' THEN                         CASE                             WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN                                 substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE \"C\" > $4                             ELSE                                 name COLLATE \"C\" > $4                             END                     ELSE                         true                 END             ORDER BY                 name COLLATE \"C\" ASC) as e order by name COLLATE \"C\" LIMIT $3'         USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after; END; $function$ "
      },
      {
        "schema": "storage",
        "name": "lock_top_prefixes",
        "signature": "lock_top_prefixes(bucket_ids text[], names text[])",
        "return_type": "void",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.lock_top_prefixes(bucket_ids text[], names text[])  RETURNS void  LANGUAGE plpgsql  SECURITY DEFINER AS $function$ DECLARE     v_bucket text;     v_top text; BEGIN     FOR v_bucket, v_top IN         SELECT DISTINCT t.bucket_id,             split_part(t.name, '/', 1) AS top         FROM unnest(bucket_ids, names) AS t(bucket_id, name)         WHERE t.name <> ''         ORDER BY 1, 2         LOOP             PERFORM pg_advisory_xact_lock(hashtextextended(v_bucket || '/' || v_top, 0));         END LOOP; END; $function$ "
      },
      {
        "schema": "storage",
        "name": "objects_delete_cleanup",
        "signature": "objects_delete_cleanup()",
        "return_type": "trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.objects_delete_cleanup()  RETURNS trigger  LANGUAGE plpgsql  SECURITY DEFINER AS $function$ DECLARE     v_bucket_ids text[];     v_names      text[]; BEGIN     IF current_setting('storage.gc.prefixes', true) = '1' THEN         RETURN NULL;     END IF;     PERFORM set_config('storage.gc.prefixes', '1', true);     SELECT COALESCE(array_agg(d.bucket_id), '{}'),            COALESCE(array_agg(d.name), '{}')     INTO v_bucket_ids, v_names     FROM deleted AS d     WHERE d.name <> '';     PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);     PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);     RETURN NULL; END; $function$ "
      },
      {
        "schema": "storage",
        "name": "objects_insert_prefix_trigger",
        "signature": "objects_insert_prefix_trigger()",
        "return_type": "trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.objects_insert_prefix_trigger()  RETURNS trigger  LANGUAGE plpgsql AS $function$ BEGIN     PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");     NEW.level := \"storage\".\"get_level\"(NEW.\"name\");     RETURN NEW; END; $function$ "
      },
      {
        "schema": "storage",
        "name": "objects_update_cleanup",
        "signature": "objects_update_cleanup()",
        "return_type": "trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.objects_update_cleanup()  RETURNS trigger  LANGUAGE plpgsql  SECURITY DEFINER AS $function$ DECLARE     -- NEW - OLD (destinations to create prefixes for)     v_add_bucket_ids text[];     v_add_names      text[];     -- OLD - NEW (sources to prune)     v_src_bucket_ids text[];     v_src_names      text[]; BEGIN     IF TG_OP <> 'UPDATE' THEN         RETURN NULL;     END IF;     -- 1) Compute NEW\u2212OLD (added paths) and OLD\u2212NEW (moved-away paths)     WITH added AS (         SELECT n.bucket_id, n.name         FROM new_rows n         WHERE n.name <> '' AND position('/' in n.name) > 0         EXCEPT         SELECT o.bucket_id, o.name FROM old_rows o WHERE o.name <> ''     ),     moved AS (          SELECT o.bucket_id, o.name          FROM old_rows o          WHERE o.name <> ''          EXCEPT          SELECT n.bucket_id, n.name FROM new_rows n WHERE n.name <> ''     )     SELECT         -- arrays for ADDED (dest) in stable order         COALESCE( (SELECT array_agg(a.bucket_id ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),         COALESCE( (SELECT array_agg(a.name      ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),         -- arrays for MOVED (src) in stable order         COALESCE( (SELECT array_agg(m.bucket_id ORDER BY m.bucket_id, m.name) FROM moved m), '{}' ),         COALESCE( (SELECT array_agg(m.name      ORDER BY m.bucket_id, m.name) FROM moved m), '{}' )     INTO v_add_bucket_ids, v_add_names, v_src_bucket_ids, v_src_names;     -- Nothing to do?     IF (array_length(v_add_bucket_ids, 1) IS NULL) AND (array_length(v_src_bucket_ids, 1) IS NULL) THEN         RETURN NULL;     END IF;     -- 2) Take per-(bucket, top) locks: ALL prefixes in consistent global order to prevent deadlocks     DECLARE         v_all_bucket_ids text[];         v_all_names text[];     BEGIN         -- Combine source and destination arrays for consistent lock ordering         v_all_bucket_ids := COALESCE(v_src_bucket_ids, '{}') || COALESCE(v_add_bucket_ids, '{}');         v_all_names := COALESCE(v_src_names, '{}') || COALESCE(v_add_names, '{}');         -- Single lock call ensures consistent global ordering across all transactions         IF array_length(v_all_bucket_ids, 1) IS NOT NULL THEN             PERFORM storage.lock_top_prefixes(v_all_bucket_ids, v_all_names);         END IF;     END;     -- 3) Create destination prefixes (NEW\u2212OLD) BEFORE pruning sources     IF array_length(v_add_bucket_ids, 1) IS NOT NULL THEN         WITH candidates AS (             SELECT DISTINCT t.bucket_id, unnest(storage.get_prefixes(t.name)) AS name             FROM unnest(v_add_bucket_ids, v_add_names) AS t(bucket_id, name)             WHERE name <> ''         )         INSERT INTO storage.prefixes (bucket_id, name)         SELECT c.bucket_id, c.name         FROM candidates c         ON CONFLICT DO NOTHING;     END IF;     -- 4) Prune source prefixes bottom-up for OLD\u2212NEW     IF array_length(v_src_bucket_ids, 1) IS NOT NULL THEN         -- re-entrancy guard so DELETE on prefixes won't recurse         IF current_setting('storage.gc.prefixes', true) <> '1' THEN             PERFORM set_config('storage.gc.prefixes', '1', true);         END IF;         PERFORM storage.delete_leaf_prefixes(v_src_bucket_ids, v_src_names);     END IF;     RETURN NULL; END; $function$ "
      },
      {
        "schema": "storage",
        "name": "objects_update_level_trigger",
        "signature": "objects_update_level_trigger()",
        "return_type": "trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.objects_update_level_trigger()  RETURNS trigger  LANGUAGE plpgsql AS $function$ BEGIN     -- Ensure this is an update operation and the name has changed     IF TG_OP = 'UPDATE' AND (NEW.\"name\" <> OLD.\"name\" OR NEW.\"bucket_id\" <> OLD.\"bucket_id\") THEN         -- Set the new level         NEW.\"level\" := \"storage\".\"get_level\"(NEW.\"name\");     END IF;     RETURN NEW; END; $function$ "
      },
      {
        "schema": "storage",
        "name": "objects_update_prefix_trigger",
        "signature": "objects_update_prefix_trigger()",
        "return_type": "trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.objects_update_prefix_trigger()  RETURNS trigger  LANGUAGE plpgsql AS $function$ DECLARE     old_prefixes TEXT[]; BEGIN     -- Ensure this is an update operation and the name has changed     IF TG_OP = 'UPDATE' AND (NEW.\"name\" <> OLD.\"name\" OR NEW.\"bucket_id\" <> OLD.\"bucket_id\") THEN         -- Retrieve old prefixes         old_prefixes := \"storage\".\"get_prefixes\"(OLD.\"name\");         -- Remove old prefixes that are only used by this object         WITH all_prefixes as (             SELECT unnest(old_prefixes) as prefix         ),         can_delete_prefixes as (              SELECT prefix              FROM all_prefixes              WHERE NOT EXISTS (                  SELECT 1 FROM \"storage\".\"objects\"                  WHERE \"bucket_id\" = OLD.\"bucket_id\"                    AND \"name\" <> OLD.\"name\"                    AND \"name\" LIKE (prefix || '%')              )          )         DELETE FROM \"storage\".\"prefixes\" WHERE name IN (SELECT prefix FROM can_delete_prefixes);         -- Add new prefixes         PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");     END IF;     -- Set the new level     NEW.\"level\" := \"storage\".\"get_level\"(NEW.\"name\");     RETURN NEW; END; $function$ "
      },
      {
        "schema": "storage",
        "name": "operation",
        "signature": "operation()",
        "return_type": "text",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.operation()  RETURNS text  LANGUAGE plpgsql  STABLE AS $function$ BEGIN     RETURN current_setting('storage.operation', true); END; $function$ "
      },
      {
        "schema": "storage",
        "name": "prefixes_delete_cleanup",
        "signature": "prefixes_delete_cleanup()",
        "return_type": "trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.prefixes_delete_cleanup()  RETURNS trigger  LANGUAGE plpgsql  SECURITY DEFINER AS $function$ DECLARE     v_bucket_ids text[];     v_names      text[]; BEGIN     IF current_setting('storage.gc.prefixes', true) = '1' THEN         RETURN NULL;     END IF;     PERFORM set_config('storage.gc.prefixes', '1', true);     SELECT COALESCE(array_agg(d.bucket_id), '{}'),            COALESCE(array_agg(d.name), '{}')     INTO v_bucket_ids, v_names     FROM deleted AS d     WHERE d.name <> '';     PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);     PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);     RETURN NULL; END; $function$ "
      },
      {
        "schema": "storage",
        "name": "prefixes_insert_trigger",
        "signature": "prefixes_insert_trigger()",
        "return_type": "trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.prefixes_insert_trigger()  RETURNS trigger  LANGUAGE plpgsql AS $function$ BEGIN     PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");     RETURN NEW; END; $function$ "
      },
      {
        "schema": "storage",
        "name": "search",
        "signature": "search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)",
        "return_type": "TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)  RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)  LANGUAGE plpgsql AS $function$ declare     can_bypass_rls BOOLEAN; begin     SELECT rolbypassrls     INTO can_bypass_rls     FROM pg_roles     WHERE rolname = coalesce(nullif(current_setting('role', true), 'none'), current_user);     IF can_bypass_rls THEN         RETURN QUERY SELECT * FROM storage.search_v1_optimised(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);     ELSE         RETURN QUERY SELECT * FROM storage.search_legacy_v1(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);     END IF; end; $function$ "
      },
      {
        "schema": "storage",
        "name": "search_legacy_v1",
        "signature": "search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)",
        "return_type": "TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)  RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)  LANGUAGE plpgsql  STABLE AS $function$ declare     v_order_by text;     v_sort_order text; begin     case         when sortcolumn = 'name' then             v_order_by = 'name';         when sortcolumn = 'updated_at' then             v_order_by = 'updated_at';         when sortcolumn = 'created_at' then             v_order_by = 'created_at';         when sortcolumn = 'last_accessed_at' then             v_order_by = 'last_accessed_at';         else             v_order_by = 'name';         end case;     case         when sortorder = 'asc' then             v_sort_order = 'asc';         when sortorder = 'desc' then             v_sort_order = 'desc';         else             v_sort_order = 'asc';         end case;     v_order_by = v_order_by || ' ' || v_sort_order;     return query execute         'with folders as (            select path_tokens[$1] as folder            from storage.objects              where objects.name ilike $2 || $3 || ''%''                and bucket_id = $4                and array_length(objects.path_tokens, 1) <> $1            group by folder            order by folder ' || v_sort_order || '      )      (select folder as \"name\",             null as id,             null as updated_at,             null as created_at,             null as last_accessed_at,             null as metadata from folders)      union all      (select path_tokens[$1] as \"name\",             id,             updated_at,             created_at,             last_accessed_at,             metadata      from storage.objects      where objects.name ilike $2 || $3 || ''%''        and bucket_id = $4        and array_length(objects.path_tokens, 1) = $1      order by ' || v_order_by || ')      limit $5      offset $6' using levels, prefix, search, bucketname, limits, offsets; end; $function$ "
      },
      {
        "schema": "storage",
        "name": "search_v1_optimised",
        "signature": "search_v1_optimised(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)",
        "return_type": "TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.search_v1_optimised(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)  RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)  LANGUAGE plpgsql  STABLE AS $function$ declare     v_order_by text;     v_sort_order text; begin     case         when sortcolumn = 'name' then             v_order_by = 'name';         when sortcolumn = 'updated_at' then             v_order_by = 'updated_at';         when sortcolumn = 'created_at' then             v_order_by = 'created_at';         when sortcolumn = 'last_accessed_at' then             v_order_by = 'last_accessed_at';         else             v_order_by = 'name';         end case;     case         when sortorder = 'asc' then             v_sort_order = 'asc';         when sortorder = 'desc' then             v_sort_order = 'desc';         else             v_sort_order = 'asc';         end case;     v_order_by = v_order_by || ' ' || v_sort_order;     return query execute         'with folders as (            select (string_to_array(name, ''/''))[level] as name            from storage.prefixes              where lower(prefixes.name) like lower($2 || $3) || ''%''                and bucket_id = $4                and level = $1            order by name ' || v_sort_order || '      )      (select name,             null as id,             null as updated_at,             null as created_at,             null as last_accessed_at,             null as metadata from folders)      union all      (select path_tokens[level] as \"name\",             id,             updated_at,             created_at,             last_accessed_at,             metadata      from storage.objects      where lower(objects.name) like lower($2 || $3) || ''%''        and bucket_id = $4        and level = $1      order by ' || v_order_by || ')      limit $5      offset $6' using levels, prefix, search, bucketname, limits, offsets; end; $function$ "
      },
      {
        "schema": "storage",
        "name": "search_v2",
        "signature": "search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text, sort_order text DEFAULT 'asc'::text, sort_column text DEFAULT 'name'::text, sort_column_after text DEFAULT ''::text)",
        "return_type": "TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text, sort_order text DEFAULT 'asc'::text, sort_column text DEFAULT 'name'::text, sort_column_after text DEFAULT ''::text)  RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)  LANGUAGE plpgsql  STABLE AS $function$ DECLARE     sort_col text;     sort_ord text;     cursor_op text;     cursor_expr text;     sort_expr text; BEGIN     -- Validate sort_order     sort_ord := lower(sort_order);     IF sort_ord NOT IN ('asc', 'desc') THEN         sort_ord := 'asc';     END IF;     -- Determine cursor comparison operator     IF sort_ord = 'asc' THEN         cursor_op := '>';     ELSE         cursor_op := '<';     END IF;          sort_col := lower(sort_column);     -- Validate sort column       IF sort_col IN ('updated_at', 'created_at') THEN         cursor_expr := format(             '($5 = '''' OR ROW(date_trunc(''milliseconds'', %I), name COLLATE \"C\") %s ROW(COALESCE(NULLIF($6, '''')::timestamptz, ''epoch''::timestamptz), $5))',             sort_col, cursor_op         );         sort_expr := format(             'COALESCE(date_trunc(''milliseconds'', %I), ''epoch''::timestamptz) %s, name COLLATE \"C\" %s',             sort_col, sort_ord, sort_ord         );     ELSE         cursor_expr := format('($5 = '''' OR name COLLATE \"C\" %s $5)', cursor_op);         sort_expr := format('name COLLATE \"C\" %s', sort_ord);     END IF;     RETURN QUERY EXECUTE format(         $sql$         SELECT * FROM (             (                 SELECT                     split_part(name, '/', $4) AS key,                     name,                     NULL::uuid AS id,                     updated_at,                     created_at,                     NULL::timestamptz AS last_accessed_at,                     NULL::jsonb AS metadata                 FROM storage.prefixes                 WHERE name COLLATE \"C\" LIKE $1 || '%%'                     AND bucket_id = $2                     AND level = $4                     AND %s                 ORDER BY %s                 LIMIT $3             )             UNION ALL             (                 SELECT                     split_part(name, '/', $4) AS key,                     name,                     id,                     updated_at,                     created_at,                     last_accessed_at,                     metadata                 FROM storage.objects                 WHERE name COLLATE \"C\" LIKE $1 || '%%'                     AND bucket_id = $2                     AND level = $4                     AND %s                 ORDER BY %s                 LIMIT $3             )         ) obj         ORDER BY %s         LIMIT $3         $sql$,         cursor_expr,    -- prefixes WHERE         sort_expr,      -- prefixes ORDER BY         cursor_expr,    -- objects WHERE         sort_expr,      -- objects ORDER BY         sort_expr       -- final ORDER BY     )     USING prefix, bucket_name, limits, levels, start_after, sort_column_after; END; $function$ "
      },
      {
        "schema": "storage",
        "name": "update_updated_at_column",
        "signature": "update_updated_at_column()",
        "return_type": "trigger",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION storage.update_updated_at_column()  RETURNS trigger  LANGUAGE plpgsql AS $function$ BEGIN     NEW.updated_at = now();     RETURN NEW;  END; $function$ "
      },
      {
        "schema": "vault",
        "name": "_crypto_aead_det_decrypt",
        "signature": "_crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)  RETURNS bytea  LANGUAGE c  IMMUTABLE AS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_decrypt_by_id$function$ "
      },
      {
        "schema": "vault",
        "name": "_crypto_aead_det_encrypt",
        "signature": "_crypto_aead_det_encrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_encrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)  RETURNS bytea  LANGUAGE c  IMMUTABLE AS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_encrypt_by_id$function$ "
      },
      {
        "schema": "vault",
        "name": "_crypto_aead_det_noncegen",
        "signature": "_crypto_aead_det_noncegen()",
        "return_type": "bytea",
        "language": "c",
        "definition": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_noncegen()  RETURNS bytea  LANGUAGE c  IMMUTABLE AS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_noncegen$function$ "
      },
      {
        "schema": "vault",
        "name": "create_secret",
        "signature": "create_secret(new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid)",
        "return_type": "uuid",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION vault.create_secret(new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid)  RETURNS uuid  LANGUAGE plpgsql  SECURITY DEFINER  SET search_path TO '' AS $function$ DECLARE   rec record; BEGIN   INSERT INTO vault.secrets (secret, name, description)   VALUES (     new_secret,     new_name,     new_description   )   RETURNING * INTO rec;   UPDATE vault.secrets s   SET secret = encode(vault._crypto_aead_det_encrypt(     message := convert_to(rec.secret, 'utf8'),     additional := convert_to(s.id::text, 'utf8'),     key_id := 0,     context := 'pgsodium'::bytea,     nonce := rec.nonce   ), 'base64')   WHERE id = rec.id;   RETURN rec.id; END $function$ "
      },
      {
        "schema": "vault",
        "name": "update_secret",
        "signature": "update_secret(secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid)",
        "return_type": "void",
        "language": "plpgsql",
        "definition": "CREATE OR REPLACE FUNCTION vault.update_secret(secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid)  RETURNS void  LANGUAGE plpgsql  SECURITY DEFINER  SET search_path TO '' AS $function$ DECLARE   decrypted_secret text := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE id = secret_id); BEGIN   UPDATE vault.secrets s   SET     secret = CASE WHEN new_secret IS NULL THEN s.secret                   ELSE encode(vault._crypto_aead_det_encrypt(                     message := convert_to(new_secret, 'utf8'),                     additional := convert_to(s.id::text, 'utf8'),                     key_id := 0,                     context := 'pgsodium'::bytea,                     nonce := s.nonce                   ), 'base64') END,     name = coalesce(new_name, s.name),     description = coalesce(new_description, s.description),     updated_at = now()   WHERE s.id = secret_id; END $function$ "
      }
    ]
  },
  "naming_map": {
    "tables": [],
    "columns": []
  },
  "rules": {
    "multi_tenant": true,
    "tenant_key": "company_code",
    "auth_model": "supabase_auth"
  },
  "constraints": {
    "rls_required": true,
    "no_local_storage_for_state": false,
    "no_secrets_in_logs": true
  }
}